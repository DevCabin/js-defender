<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Defender - Space Shooter</title>
<style>
  body {
    margin: 0; padding: 0;
    background: #282a36; color: #f8f8f2;
    font-family: 'Courier New', monospace;
    display: flex; justify-content: center; align-items: center; height: 100vh;
  }
  #gameCanvas {
    border: 2px solid #44475a;
    background: linear-gradient(to bottom, #282a36 0%, #21222c 50%, #191a21 100%);
  }
  #ui { position: absolute; top: 10px; left: 10px; z-index: 10; }
  #startScreen, #gameOverScreen {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    text-align: center; z-index: 20; background: rgba(40,42,54,0.9);
    padding: 20px; border: 2px solid #6272a4; border-radius: 8px;
  }
  input { background: #44475a; border: 1px solid #6272a4; color: #f8f8f2; padding: 5px; margin: 10px; }
  button { background: #44475a; border: 1px solid #6272a4; color: #f8f8f2; padding: 10px 20px; cursor: pointer; }
  button:hover { background: #6272a4; }
  button.affordable { background: #50fa7b; color: #282a36; }
  button.affordable:hover { background: #7bfaad; }
  #shopScreen {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    text-align: center; z-index: 20; background: rgba(40,42,54,0.95);
    padding: 20px; border: 2px solid #6272a4; border-radius: 8px;
    opacity: 0; transition: opacity 0.3s ease-in-out; display: none;
  }
  #shopScreen.show { opacity: 1; }
</style>
</head>
<body>
<canvas id="gameCanvas" width="1200" height="600"></canvas>

<div id="ui">
  <div>Score: <span id="score">0</span></div>
  <div>Lives: <span id="lives">3</span></div>
  <div>Bombs: <span id="bombs">3</span></div>
  <div>Shield: <span id="shield">100</span>%</div>
  <div>Time: <span id="time">0</span>s</div>
  <div>Parsecs: <span id="distance">0</span></div>
  <div style="margin-top: 10px;">
    <div style="color: #50fa7b; font-size: 12px;">POWER</div>
    <canvas id="powerMeter" width="100" height="20" style="border: 1px solid #6272a4; background: #282a36;"></canvas>
  </div>
</div>

<div id="startScreen">
  <h1>DEFENDER</h1>
  <p>Protect the planet from alien invaders!</p>
  <input type="text" id="playerName" placeholder="Enter your name" maxlength="20" />
  <br />
  <button onclick="startGame()">START GAME</button>
  <br /><br />
  <p>Controls:</p>
  <p>Arrow Keys: Move | Spacebar: Laser | B: Bomb | T: Torpedo (if purchased)</p>
</div>

<div id="gameOverScreen" style="display: none;">
  <h1>GAME OVER</h1>
  <p id="finalScore"></p>
  <p id="playerNameDisplay"></p>
  <button onclick="resetGame()">PLAY AGAIN</button>
</div>

<div id="shopScreen">
  <h1>UPGRADE SHOP</h1>
  <p id="shopCredits">Credits: 0</p>
  <div id="shopUpgrades"></div>
  <button onclick="closeShop()">CONTINUE GAME</button>
</div>

<script>
/* ================== Canvas & Core ================== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState = 'start';
let playerName = '';
let gameTime = 0;     // ms since run started
let lastTime  = 0;    // last RAF timestamp
let score = 0, lives = 3, bombs = 3, shield = 100;
let lastBossTime = 0; // legacy boss timing
let cameraX = 0;
let distanceTraveled = 0;
let highScores = [];
let gameSpeed = 1.0;

let credits = 0;
let lastShopTime = 0;
let upgrades = {
  plasmaBlaster: false,
  missiles: 0,          // 0..2
  homingMissiles: 0,    // 0..2
  bombCapacity: false,
  torpedo: false        // NEW
};

let audioContext = null;
let lastLaserTime = 0;
function ensureAudio(){ if(!audioContext){ try{ audioContext=new (window.AudioContext||window.webkitAudioContext)(); }catch(_){} } }
document.addEventListener('keydown', ensureAudio, { once:true });
document.addEventListener('click', ensureAudio, { once:true });

/* ================== Input ================== */
let keys = {};
let shootTimerMs = 0;
let homingMissileTimerMs = 0;
let torpedoTimerMs = 0; // cooldown timer
const FRAME_MS = 16.67;
const baseShootDelayMs = 8 * FRAME_MS;
const homingMissileDelayMs = 24 * FRAME_MS;
const torpedoCooldownMs = 1400; // ~1.4s between torpedoes

document.addEventListener('keydown', (e)=>{
  keys[e.key] = true;
  if (e.key === ' ') e.preventDefault();
  if (e.key && e.key.toLowerCase() === 'b' && gameState === 'playing') dropBomb();
  if (e.key && e.key.toLowerCase() === 't' && gameState === 'playing') fireTorpedo();
  if (e.key === 'Enter'){
    if (gameState === 'start') startGame();
    else if (gameState === 'shop') closeShop();
  }
});
document.addEventListener('keyup', (e)=>{ keys[e.key] = false; });

/* ================== Entities & World ================== */
let player = {
  x: 100, y: 300, width: 20, height: 16,
  vx: 0, vy: 0,
  maxSpeed: 180,      // px/sec
  accel: 360          // px/sec^2
};

let bullets = [];
let enemies = [];
let explosions = [];
let powerUps = [];
let stars = [];
let terrain = [];

let terrainGeneratedUpTo = 0;

/* ------- Terrain ------- */
function initTerrain(){ terrain=[]; generateTerrainSegment(0, canvas.width*3); }
function generateTerrainSegment(startX, endX){
  for (let x=startX; x<endX; x+=10){
    let h = 450 + Math.sin(x*0.02)*20 + Math.sin(x*0.005)*40;
    if (Math.random()<0.1){
      let w = 40 + Math.random()*60, d = 20 + Math.random()*30;
      for (let i=0;i<w;i+=10){
        if (x+i < endX){
          let ch = h + Math.sin((i/w)*Math.PI)*d;
          terrain.push({x:x+i, y:ch});
        }
      }
      x += w;
    } else {
      terrain.push({x, y:h});
    }
  }
  terrainGeneratedUpTo = endX;
}
function getTerrainHeight(x){
  if (terrain.length < 2) return 450;
  let lo=0, hi=terrain.length-2;
  while (lo<=hi){
    const mid=(lo+hi)>>1;
    const ax=terrain[mid].x, bx=terrain[mid+1].x;
    if (x<ax) hi=mid-1;
    else if (x>bx) lo=mid+1;
    else {
      const t=(x-ax)/((bx-ax)||1);
      return terrain[mid].y*(1-t)+terrain[mid+1].y*t;
    }
  }
  return 450;
}

/* ------- Stars ------- */
function initStars(){
  stars = [];
  for (let i=0;i<120;i++){
    stars.push({
      x: Math.random()*canvas.width + cameraX,
      y: Math.random()*canvas.height*0.8,
      brightness: Math.random()
    });
  }
}

/* ================== Game Flow ================== */
function startMainLoop(){ lastTime=performance.now(); requestAnimationFrame(gameLoop); }

function startGame(){
  playerName = document.getElementById('playerName').value || 'Anonymous';
  document.getElementById('startScreen').style.display='none';
  gameState='playing';
  resetGameVars();
  initTerrain(); initStars();
  startMainLoop();
}
function resetGameVars(){
  gameTime=0; score=0; lives=3; bombs=3; shield=100;
  lastBossTime=0; shootTimerMs=0; homingMissileTimerMs=0; torpedoTimerMs=0;
  player.x=100; player.y=300; player.vx=0; player.vy=0;
  bullets=[]; enemies=[]; explosions=[]; powerUps=[];
  cameraX=0; distanceTraveled=0; credits=0; lastShopTime=0;
  lastSandwormTime = -1; // NEW boss timer
}
function resetGame(){
  document.getElementById('gameOverScreen').style.display='none';
  document.getElementById('startScreen').style.display='block';
  gameState='start';
}

/* ================== Weapons ================== */
function shoot(){
  if (upgrades.plasmaBlaster){
    bullets.push({ x: player.x+player.width, y: player.y+player.height/2, vx: 8, vy: 0, type:'plasma', width:20, height:6, damage:2 });
  } else {
    bullets.push({ x: player.x+player.width, y: player.y+player.height/2, vx: 12, vy: 0, type:'laser', width:12, height:3, damage:1 });
  }
  if (upgrades.missiles>=1){
    bullets.push({ x:player.x+player.width, y:player.y+player.height/2+8, vx:6, vy:0, type:'missile', width:8, height:4, damage:3, tier:1 });
  }
  if (upgrades.missiles>=2){
    bullets.push({ x:player.x+player.width, y:player.y+player.height/2-8, vx:6, vy:0, type:'missile', width:8, height:4, damage:3, tier:2 });
  }
  playLaserSound();
}

function shootHomingMissiles(){
  if (upgrades.homingMissiles>=1){
    let target=null, maxH=0;
    enemies.forEach(e=>{ if (e.health>maxH){ maxH=e.health; target=e; } });
    if (target){
      let dx = (target.x+target.width/2) - (player.x+player.width);
      let dy = (target.y+target.height/2) - (player.y+player.height/2);
      let d = Math.hypot(dx,dy)||1, speed=5;
      bullets.push({ x:player.x+player.width, y:player.y+player.height/2-8, vx:(dx/d)*speed, vy:(dy/d)*speed,
        type:'homing', width:6, height:6, damage:2, target, tier:1 });
    }
  }
  if (upgrades.homingMissiles>=2){
    let target=null, best=Infinity;
    enemies.forEach(e=>{
      const healthy=(e.health===e.maxHealth)||e.health>5;
      if (!healthy) return;
      let dx=(e.x+e.width/2)-(player.x+player.width);
      let dy=(e.y+e.height/2)-(player.y+player.height/2);
      const d=Math.hypot(dx,dy); if (d<best){ best=d; target=e; }
    });
    if (target){
      let dx = (target.x+target.width/2) - (player.x+player.width);
      let dy = (target.y+target.height/2) - (player.y+player.height/2);
      let d = Math.hypot(dx,dy)||1, speed=5;
      bullets.push({ x:player.x+player.width, y:player.y+player.height/2+8, vx:(dx/d)*speed, vy:(dy/d)*speed,
        type:'homing', width:6, height:6, damage:2, target, tier:2 });
    }
  }
}

function dropBomb(){
  if (bombs>0){
    bombs--;
    bullets.push({ x:player.x, y:player.y+player.height, vx:0, vy:5, type:'bomb', width:8, height:8, damage:3 });
  }
}

/* --- NEW: Torpedo secondary weapon (T) --- */
function fireTorpedo(){
  if (!upgrades.torpedo || gameState!=='playing') return;
  if (torpedoTimerMs > 0) return;
  torpedoTimerMs = torpedoCooldownMs;
  // Big electric torpedo: fast, high damage, small AoE on impact
  bullets.push({
    x: player.x + player.width,
    y: player.y + player.height/2,
    vx: 16, vy: 0,
    type: 'torpedo',
    width: 26, height: 10,
    damage: 12,
    pierce: 1 // can pass through 1 enemy before exploding
  });
}

/* ================== Spawning ================== */
// Progressive saucer scaling (every 35s)
function getSaucerTier(){ return Math.floor(gameTime / 35000); }
function saucerScaleForTier(tier){
  // size +2%..+3% per tier (multiplicative)
  const sizeUp = 1 + (0.02 + Math.random()*0.01) * tier;
  // health +20%..+30% per tier
  const hpUp = 1 + (0.20 + Math.random()*0.10) * tier;
  // weapon +2%..+10% per tier
  const wepUp = 1 + (0.02 + Math.random()*0.08) * tier;
  return { sizeUp, hpUp, wepUp };
}

let lastSandwormTime = -1;
const SANDWORM_FIRST_MS = 180000; // ~3 minutes
const SANDWORM_COOLDOWN_MS = 90000; // every 1.5 minutes thereafter

function spawnEnemy(deltaTime){
  const t = gameTime;

  // Base flying/ground spawns (probabilistic per ms)
  const basePerSec = Math.min(0.03 + t * 0.0000006, 2.4);
  const p = (basePerSec/1000) * deltaTime;

  // Dinosaur cap
  const dinos = enemies.filter(e=>e.type==='dinosaur').length;
  const maxDinos = t<15000?0 : t<45000?1 : t<90000?2 : 3;

  if (Math.random() < p){
    let type = ['fighter','bomber','dinosaur'][Math.floor(Math.random()*3)];
    if (type==='dinosaur' && dinos>=maxDinos) type = Math.random()<0.5 ? 'fighter' : 'bomber';

    const spawnX = cameraX + canvas.width + 50;
    // Base health
    let enemyHealth = (type==='dinosaur') ? 8 + Math.floor(t/45000) : 1 + Math.floor(t/60000);
    let w = (type==='dinosaur')?45:25;
    let h = (type==='dinosaur')?35:20;

    // Progressive saucer buffs (apply to fighters only)
    let weaponScale = 1, tier = 0;
    if (type==='fighter'){
      tier = getSaucerTier();
      const { sizeUp, hpUp, wepUp } = saucerScaleForTier(tier);
      w = Math.round(w * sizeUp);
      h = Math.round(h * sizeUp);
      enemyHealth = Math.ceil(enemyHealth * hpUp);
      weaponScale = wepUp;
    }

    enemies.push({
      type, x: spawnX,
      y: type==='dinosaur' ? getTerrainHeight(spawnX)-35 : Math.random()*(canvas.height-200),
      width: (type==='boss')?80 : w,
      height:(type==='boss')?60 : h,
      vx: -2.0 - Math.random()*1 - Math.floor(t/60000)*0.15,
      vy: 0,
      health: enemyHealth,
      maxHealth: enemyHealth,
      shootTimerMs: 0,
      walkTimer: type==='dinosaur'? Math.random()*100 : 0,
      moveTimer: 0,
      tier,
      weaponScale
    });
  }

  // Legacy boss timer (optional keep)
  const bossInterval = Math.max(20000 - Math.floor(t/60000)*3000, 10000);
  if (t - lastBossTime > bossInterval){
    const spawnX = cameraX + canvas.width + 100;
    const bossHealth = 10 + Math.floor(t/45000)*5;
    enemies.push({
      type:'boss', x:spawnX,
      y: canvas.height/2 - 40 + (Math.random()*120 - 60),
      width:80, height:60,
      vx: -1 - Math.floor(t/120000)*0.15, vy:0,
      health: bossHealth, maxHealth: bossHealth,
      shootTimerMs: 0, moveTimer: 0, tier:0, weaponScale:1.0
    });
    lastBossTime = t;
  }

  // NEW: Sand Worm boss
  if ((t >= SANDWORM_FIRST_MS) && (lastSandwormTime < 0 || t - lastSandwormTime >= SANDWORM_COOLDOWN_MS)){
    spawnSandworm();
    lastSandwormTime = t;
  }
}

function spawnSandworm(){
  // Single big boss that patrols screen perimeter clockwise
  const hp = 300 + Math.floor(gameTime/60000)*80; // scales a bit over time
  enemies.push({
    type: 'sandworm',
    x: cameraX + canvas.width/2, y: canvas.height - 80,
    width: 120, height: 40,
    vx: 0, vy: 0,
    health: hp, maxHealth: hp,
    tParam: 0,                 // 0..1 along perimeter
    speedPerSec: 0.08,         // fraction of perimeter per second
    shootTimerMs: 0,
    weaponScale: 1 + Math.min(gameTime/600000, 0.5), // grows slowly
    segmentCount: 8
  });
}

/* ================== Power-ups ================== */
function spawnPowerUp(x,y,isBoss){
  let types = ['bombs','shield']; if (isBoss) types.push('life');
  let type = types[Math.floor(Math.random()*types.length)];
  powerUps.push({
    x,y, vx:0, vy:0, type,
    timerMs:0, hoverTimerMs:0,
    hoverDurationMs: (480+Math.random()*240)*FRAME_MS,
    width:16, height:16
  });
}

/* ================== Updates ================== */
function updatePlayer(dt, deltaTime){
  const acc = player.accel * dt;
  if (keys['ArrowLeft'])  player.vx = Math.max(player.vx - acc, -player.maxSpeed);
  if (keys['ArrowRight']) player.vx = Math.min(player.vx + acc,  player.maxSpeed);
  if (keys['ArrowUp'])    player.vy = Math.max(player.vy - acc, -player.maxSpeed);
  if (keys['ArrowDown'])  player.vy = Math.min(player.vy + acc,  player.maxSpeed);

  if (keys[' '] && gameState==='playing'){
    shootTimerMs += deltaTime;
    homingMissileTimerMs += deltaTime;
    let currentShootDelay = upgrades.plasmaBlaster ? baseShootDelayMs*1.5 : baseShootDelayMs;
    if (shootTimerMs>=currentShootDelay){ shoot(); shootTimerMs=0; }
    if (homingMissileTimerMs>=homingMissileDelayMs){ shootHomingMissiles(); homingMissileTimerMs=0; }
  } else { shootTimerMs=0; homingMissileTimerMs=0; }

  if (torpedoTimerMs>0) torpedoTimerMs = Math.max(0, torpedoTimerMs - deltaTime);

  const damp = Math.pow(0.92, dt*60);
  player.vx *= damp; player.vy *= damp;

  if (player.vx>0) distanceTraveled += player.vx * dt;

  player.x += player.vx * dt;
  player.y += player.vy * dt;

  cameraX = player.x - canvas.width/2;

  if (cameraX + canvas.width*2 > terrainGeneratedUpTo){
    generateTerrainSegment(terrainGeneratedUpTo, terrainGeneratedUpTo + canvas.width);
  }
  if (player.y<0) player.y=0;
  if (player.y>canvas.height-player.height) player.y=canvas.height-player.height;
}

function updateBullets(dt, deltaTime){
  for (let i=bullets.length-1;i>=0;i--){
    let b = bullets[i];

    // Lifetimes for enemy homing (to prevent eternal orbit)
    if (b.type==='enemyHoming'){
      b.lifeMs = (b.lifeMs||0) + deltaTime;
      if (!b.maxLifeMs) b.maxLifeMs = 4000 + Math.random()*3000; // 4-7s
      if (b.lifeMs >= b.maxLifeMs){
        bullets.splice(i,1); continue;
      }
    }

    // Homing adjust
    if (b.type==='homing' && b.target && enemies.includes(b.target)){
      let t=b.target; let dx=t.x+t.width/2-b.x; let dy=t.y+t.height/2-b.y;
      let dist=Math.hypot(dx,dy)||1; const speed=5, k=0.1;
      let tvx=(dx/dist)*speed, tvy=(dy/dist)*speed;
      b.vx += (tvx-b.vx)*k; b.vy += (tvy-b.vy)*k;
      let s=Math.hypot(b.vx,b.vy)||1; b.vx=(b.vx/s)*speed; b.vy=(b.vy/s)*speed;
    }
    if (b.type==='enemyHoming' && b.target){
      let t=b.target; let dx=t.x+t.width/2-b.x; let dy=t.y+t.height/2-b.y;
      let dist=Math.hypot(dx,dy)||1; const speed=4.5, k=0.08;
      let tvx=(dx/dist)*speed, tvy=(dy/dist)*speed;
      b.vx += (tvx-b.vx)*k; b.vy += (tvy-b.vy)*k;
      let s=Math.hypot(b.vx,b.vy)||1; b.vx=(b.vx/s)*speed; b.vy=(b.vy/s)*speed;
    }

    b.x += b.vx * dt;
    b.y += b.vy * dt;

    // Offscreen cull
    if (b.x > cameraX+canvas.width+100 || b.x < cameraX-100 || b.y > canvas.height+50 || b.y < -50){
      bullets.splice(i,1); continue;
    }

    if (b.type==='bomb'){
      if (b.y > getTerrainHeight(b.x)-10){
        createExplosion(b.x,b.y,60); playBombExplosionSound();
        enemies.forEach(e=>{
          let d=Math.hypot(e.x+e.width/2-b.x, e.y+e.height/2-b.y);
          if (d<80) e.health -= b.damage || 3;
        });
        bullets.splice(i,1); continue;
      }
    }

    if (b.type==='torpedo'){
      // add a faint electric wobble
      b.y += Math.sin((b.x+b.y)*0.05)*0.4;
    }
  }
}

function updateEnemies(dt, deltaTime){
  for (let i=enemies.length-1;i>=0;i--){
    let e = enemies[i];
    e.x += e.vx * dt; e.y += e.vy * dt;

    if (e.type==='boss'){
      e.moveTimer += deltaTime;
      e.vy = Math.sin(e.moveTimer*0.05*0.06) * 120 * dt;
    }

    if (e.type==='dinosaur'){
      e.walkTimer += deltaTime*0.06;
      let th = getTerrainHeight(e.x+e.width/2);
      let targetY = th - e.height;
      let dy = targetY - e.y;
      e.vy = dy * 0.6 * dt; e.y += Math.sin(e.walkTimer*0.3)*0.5;
      if (Math.random()<0.005*dt*60) e.vx = -e.vx;
      if (e.y<targetY-10) e.y=targetY-10;
      if (e.y>targetY+10) e.y=targetY+10;
    }

    // NEW: Sandworm perimeter patrol
    if (e.type==='sandworm'){
      e.tParam += e.speedPerSec * (deltaTime/1000); if (e.tParam>1) e.tParam-=1;
      // perimeter path (clockwise) â€“ param t in [0,1)
      const m = 30; // margin from edges
      const left = cameraX + m, right = cameraX + canvas.width - m;
      const top = m, bottom = canvas.height - m;
      const t = e.tParam;
      let px, py;
      if (t < 0.25){ // top row
        const u = t/0.25; px = left + (right-left)*u; py = top;
      } else if (t < 0.5){ // right col
        const u = (t-0.25)/0.25; px = right; py = top + (bottom-top)*u;
      } else if (t < 0.75){ // bottom row
        const u = (t-0.5)/0.25; px = right - (right-left)*u; py = bottom;
      } else { // left col
        const u = (t-0.75)/0.25; px = left; py = bottom - (bottom-top)*u;
      }
      e.x = px - e.width/2;
      e.y = py - e.height/2;

      // fire at intervals
      e.shootTimerMs += deltaTime;
      const sd = 900 - Math.min(gameTime/6000, 500); // gets a bit faster over time
      if (e.shootTimerMs > sd){
        e.shootTimerMs = 0;
        // bursts of missiles aimed at player
        const headX = e.x + e.width/2, headY = e.y + e.height/2;
        for (let k=0;k<2;k++){
          let dx = (player.x+player.width/2) - headX;
          let dy = (player.y+player.height/2) - headY;
          let d = Math.hypot(dx,dy)||1;
          const sp = 4.8 + Math.random()*0.8;
          bullets.push({
            x: headX, y: headY,
            vx: (dx/d)*sp, vy: (dy/d)*sp,
            type: 'enemyHoming',
            width: 6, height: 6,
            target: player,
            damage: Math.round(10 * e.weaponScale)
          });
        }
      }
    }

    // Enemy shooting cadence
    e.shootTimerMs = (e.shootTimerMs||0) + deltaTime;
    let sd;
    if (gameTime<30000) sd=5000+Math.random()*3300;
    else if (gameTime<60000) sd=4000+Math.random()*2000;
    else if (gameTime<120000) sd=3000+Math.random()*1500;
    else sd=2000+Math.random()*1000;

    if (e.shootTimerMs > sd && e.type!=='sandworm'){ // worm handles its own fire
      if (e.type==='dinosaur'){
        let dx=player.x+player.width/2-e.x, dy=player.y+player.height/2-e.y;
        let d=Math.hypot(dx,dy)||1; let sp=4.5;
        bullets.push({ x:e.x, y:e.y+e.height/2, vx:(dx/d)*sp, vy:(dy/d)*sp,
          type:'enemyHoming', width:5, height:5, target:player, damage:10 });
      } else {
        // Fighter/Bomber fire; fighters scale with tier weaponScale
        const baseSpeed = (e.type==='fighter') ? 3.2*e.weaponScale : 3.2;
        const dmg = (e.type==='fighter') ? Math.round(10 * e.weaponScale) : 10;
        bullets.push({ x:e.x, y:e.y+e.height/2, vx:-baseSpeed, vy:0, type:'enemy', width:6, height:6, damage:dmg });
      }
      e.shootTimerMs = 0;
    }

    // Cull and death
    if (e.x < cameraX-100 || e.health<=0){
      if (e.health<=0){
        createExplosion(e.x+e.width/2, e.y+e.height/2, e.type==='boss'||e.type==='sandworm'? 90:40);
        playExplosionSound();
        let enemyCredits =
          e.type==='sandworm' ? 120 :
          e.type==='boss' ? 50 :
          e.type==='dinosaur' ? 10 :
          e.type==='bomber' ? 5 : 1;
        credits += enemyCredits;
        score += e.type==='sandworm' ? 1200 :
                 e.type==='boss' ? 500 :
                 e.type==='dinosaur' ? 150 : 100;
        if (Math.random() < (e.type==='boss'||e.type==='sandworm' ? 1 : 0.3)) spawnPowerUp(e.x, e.y, (e.type==='boss'||e.type==='sandworm'));
      }
      enemies.splice(i,1);
    }
  }
}

function updatePowerUps(dt, deltaTime){
  for (let i=powerUps.length-1;i>=0;i--){
    let p=powerUps[i]; p.hoverTimerMs+=deltaTime;
    if (p.hoverTimerMs >= p.hoverDurationMs) p.vy = 120*dt;
    let dx=(player.x+player.width/2)-(p.x+p.width/2);
    let dy=(player.y+player.height/2)-(p.y+p.height/2);
    let dist=Math.hypot(dx,dy)||1;
    if (dist<150){
      let strength=Math.max(0.3,2 - dist/75);
      let ang=Math.atan2(dy,dx);
      p.vx += Math.cos(ang)*strength*6*dt;
      p.vy += Math.sin(ang)*strength*6*dt;
      p.vx *= Math.pow(0.9, dt*60); p.vy *= Math.pow(0.9, dt*60);
    } else {
      p.vx *= Math.pow(0.95, dt*60); p.vy *= Math.pow(0.95, dt*60);
    }
    p.x += p.vx*dt; p.y += p.vy*dt; p.timerMs=(p.timerMs||0)+deltaTime;
    if (p.y>canvas.height || p.timerMs>10000){ powerUps.splice(i,1); continue; }
    if (checkCollision(player,p)){
      if (p.type==='bombs'){ const maxB = upgrades.bombCapacity?50:9; bombs = Math.min(bombs+3, maxB); }
      if (p.type==='shield'){ shield = Math.min(shield+25, 100); }
      if (p.type==='life'){ lives++; }
      score += 50; playPowerUpSound(); powerUps.splice(i,1);
    }
  }
}

function updateExplosions(deltaTime){
  for (let i=explosions.length-1;i>=0;i--){
    let ex=explosions[i]; ex.timerMs += deltaTime;
    if (ex.timerMs >= ex.maxTimerMs) explosions.splice(i,1);
  }
}

/* ================== Collisions ================== */
function checkCollision(a,b){
  return a.x < b.x + b.width && a.x + a.width > b.x &&
         a.y < b.y + b.height && a.y + a.height > b.y;
}

function checkCollisions(){
  // Player bullets vs enemies
  for (let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    if (b.type==='enemy' || b.type==='enemyHoming') continue;

    for (let j=enemies.length-1;j>=0;j--){
      let e=enemies[j];
      if (checkCollision(b,e)){
        e.health -= b.damage || 1;
        // torpedo pierce/aoe
        if (b.type==='torpedo'){
          if (b.pierce>0){ b.pierce--; } else {
            createExplosion(b.x,b.y,70);
            // small AoE splash
            enemies.forEach(en=>{
              const d=Math.hypot(en.x+en.width/2-b.x, en.y+en.height/2-b.y);
              if (d<85) en.health -= 6;
            });
            bullets.splice(i,1);
          }
        } else if (b.type==='laser' || b.type==='plasma'){
          bullets.splice(i,1);
        }
        createExplosion(b.x,b.y,25);
        break;
      }
    }
  }

  // Enemy bullets vs player (use bullet.damage if present)
  for (let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    if (b.type!=='enemy' && b.type!=='enemyHoming') continue;
    if (checkCollision(b, player)){
      shield -= (b.damage || 10);
      bullets.splice(i,1);
      createExplosion(player.x+player.width/2, player.y+player.height/2, 30);
    }
  }

  // Enemies vs player
  enemies.forEach(e=>{
    if (checkCollision(e,player)){
      shield -= 20;
      createExplosion(player.x+player.width/2, player.y+player.height/2, 40);
      e.health = 0;
    }
  });

  if (shield<=0){
    lives--; shield=100;
    if (lives<=0) gameOver();
  }
}

/* ================== FX & UI ================== */
function createExplosion(x,y,size){
  explosions.push({ x,y,size, timerMs:0, maxTimerMs: 20*FRAME_MS });
}

function gameOver(){
  gameState='gameOver';
  const parsecs = Math.floor(distanceTraveled/100);
  const finalScore = score + Math.floor(gameTime/1000)*10 + parsecs*5;
  if (isHighScore(finalScore)){ addHighScore(playerName, finalScore); document.getElementById('finalScore').textContent=`NEW HIGH SCORE: ${finalScore}`; }
  else { document.getElementById('finalScore').textContent=`Final Score: ${finalScore}`; }
  document.getElementById('playerNameDisplay').textContent=`Player: ${playerName} - ${parsecs} Parsecs Traveled`;
  document.getElementById('gameOverScreen').style.display='block';
}

function draw(){
  ctx.fillStyle='#282a36'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.translate(-cameraX,0);

  // stars parallax
  const parallax=0.4;
  ctx.fillStyle='#8be9fd';
  stars.forEach(s=>{
    ctx.globalAlpha = s.brightness*0.7;
    const sx = s.x + cameraX*(1-parallax);
    ctx.fillRect(sx, s.y, 1, 1);
  });
  ctx.globalAlpha = 1;

  // terrain
  ctx.strokeStyle='#ffb86c'; ctx.lineWidth=2; ctx.beginPath();
  terrain.forEach((p,i)=>{ i===0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y); }); ctx.stroke();
  ctx.fillStyle='#bd93f9'; ctx.beginPath();
  terrain.forEach((p,i)=>{ i===0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y); });
  ctx.lineTo(canvas.width+cameraX,canvas.height); ctx.lineTo(cameraX,canvas.height); ctx.closePath(); ctx.fill();

  // player
  ctx.save(); ctx.translate(player.x+player.width/2, player.y+player.height/2);
  ctx.fillStyle='#50fa7b'; ctx.beginPath();
  ctx.moveTo(15,0); ctx.lineTo(-10,-8); ctx.lineTo(-5,0); ctx.lineTo(-10,8); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#ff5555'; ctx.beginPath();
  ctx.moveTo(-5,-3); ctx.lineTo(-15,0); ctx.lineTo(-5,3); ctx.closePath(); ctx.fill();
  ctx.restore();

  // enemies
  enemies.forEach(e=>{
    ctx.save(); ctx.translate(e.x, e.y);
    if (e.type==='dinosaur'){
      ctx.fillStyle='#50fa7b'; ctx.fillRect(8,15,16,12); ctx.fillRect(20,10,8,8);
      ctx.fillRect(10,27,2,8); ctx.fillRect(18,27,2,8);
      ctx.fillStyle='#ffffff'; ctx.fillRect(22,12,1,1); ctx.fillRect(25,12,1,1);
      ctx.fillStyle='#50fa7b'; ctx.fillRect(8,12,2,3); ctx.fillRect(12,10,2,5); ctx.fillRect(16,8,2,7);
    } else if (e.type==='fighter'){
      ctx.fillStyle='#ff5555';
      ctx.fillRect(6,8,Math.max(12, e.width-13),8); // scale a bit with width
      ctx.fillRect(2,10,4,4); ctx.fillRect( (6+Math.max(12, e.width-13)),10,4,4);
      ctx.fillStyle='#ffb86c'; ctx.fillRect(10,6,4,4);
    } else if (e.type==='bomber'){
      ctx.fillStyle='#ffb86c'; ctx.fillRect(8,12,8,6);
      ctx.fillRect(4,14,4,2); ctx.fillRect(16,14,4,2);
      ctx.fillRect(10,8,4,4);
    } else if (e.type==='boss'){
      ctx.fillStyle='#ff5555'; ctx.fillRect(10,15,20,15);
      ctx.fillStyle='#ffffff'; ctx.fillRect(14,18,2,2); ctx.fillRect(24,18,2,2);
      ctx.fillStyle='#000000'; ctx.fillRect(16,25,8,2);
      ctx.fillStyle='#ff5555'; ctx.fillRect(12,10,1,5); ctx.fillRect(27,10,1,5);
    } else if (e.type==='sandworm'){
      // draw segmented worm
      const seg = e.segmentCount||8;
      for (let s=0;s<seg;s++){
        const r = 12 - s*1.2;
        ctx.fillStyle = s===0 ? '#d2b48c' : '#bda16f';
        ctx.beginPath(); ctx.arc(e.width/2 - s*14, e.height/2, Math.max(4,r), 0, Math.PI*2); ctx.fill();
      }
      // simple eye on head
      ctx.fillStyle='#000'; ctx.fillRect(e.width/2-4, e.height/2-4, 3,3);
    }
    ctx.restore();
  });

  // bullets
  bullets.forEach(b=>{
    if (b.type==='laser'){
      ctx.strokeStyle='#8be9fd'; ctx.lineWidth=3; ctx.beginPath();
      ctx.moveTo(b.x,b.y); ctx.lineTo(b.x+12,b.y); ctx.stroke();
      ctx.strokeStyle='#ffffff'; ctx.lineWidth=1; ctx.beginPath();
      ctx.moveTo(b.x,b.y); ctx.lineTo(b.x+12,b.y); ctx.stroke();
    } else if (b.type==='plasma'){
      ctx.fillStyle='#bd93f9'; ctx.fillRect(b.x, b.y-3, b.width, b.height);
      ctx.strokeStyle='#ff79c6'; ctx.lineWidth=2; ctx.strokeRect(b.x, b.y-3, b.width, b.height);
    } else if (b.type==='missile'){
      ctx.fillStyle='#ffffff'; ctx.fillRect(b.x, b.y-2, b.width, b.height);
      ctx.fillStyle='#ff5555'; ctx.fillRect(b.x-4, b.y-1, 4, 2);
    } else if (b.type==='homing'){
      ctx.fillStyle='#ff5555'; ctx.fillRect(b.x, b.y-b.height/2, b.width, b.height);
      ctx.fillStyle='#ffffff'; ctx.fillRect(b.x-b.width/2, b.y-b.height/4, b.width/2, b.height/2);
      ctx.strokeStyle='#ff5555'; ctx.lineWidth=1; ctx.globalAlpha=0.5;
      ctx.beginPath(); ctx.arc(b.x+b.width/2, b.y, b.width*1.5, 0, Math.PI*2); ctx.stroke();
      ctx.globalAlpha=1;
    } else if (b.type==='bomb'){
      ctx.fillStyle='#f1c40f'; ctx.beginPath(); ctx.arc(b.x,b.y,4,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#ff5555'; ctx.beginPath(); ctx.arc(b.x-2,b.y-4,2,0,Math.PI*2); ctx.fill();
    } else if (b.type==='enemyHoming'){
      ctx.fillStyle='#ff8c00'; ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#cc5500'; ctx.beginPath(); ctx.arc(b.x-2,b.y-2,1.5,0,Math.PI*2); ctx.fill();
    } else if (b.type==='torpedo'){
      // big electric torpedo
      ctx.fillStyle='#8be9fd'; ctx.fillRect(b.x, b.y-b.height/2, b.width, b.height);
      ctx.strokeStyle='#bd93f9'; ctx.lineWidth=2; ctx.strokeRect(b.x, b.y-b.height/2, b.width, b.height);
      // electric arcs
      ctx.strokeStyle='#ffffff'; ctx.lineWidth=1; ctx.beginPath();
      ctx.moveTo(b.x+4, b.y-6); ctx.lineTo(b.x+10, b.y-2); ctx.lineTo(b.x+16, b.y-6); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(b.x+6, b.y+6); ctx.lineTo(b.x+12, b.y+2); ctx.lineTo(b.x+18, b.y+6); ctx.stroke();
    } else {
      ctx.fillStyle='#ff5555'; ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
    }
  });

  // explosions
  explosions.forEach(ex=>{
    const pr = ex.timerMs / ex.maxTimerMs;
    const sz = ex.size*(1-pr);
    ctx.fillStyle = `rgba(255,85,85,${1-pr})`;
    ctx.beginPath(); ctx.arc(ex.x,ex.y,sz/2,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = `rgba(255,184,108,${1-pr})`;
    ctx.beginPath(); ctx.arc(ex.x,ex.y,sz/3,0,Math.PI*2); ctx.fill();
  });

  // powerups
  powerUps.forEach(p=>{
    ctx.save(); ctx.translate(p.x+8, p.y+8);
    const op = (Math.sin((p.timerMs||0)*0.1*0.06)+1)*0.5; ctx.globalAlpha=0.3+op*0.7;
    if (p.type==='bombs'){
      ctx.fillStyle='#f1c40f'; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#282a36'; ctx.font='12px monospace'; ctx.textAlign='center'; ctx.fillText('B',0,4);
    } else if (p.type==='shield'){
      ctx.strokeStyle='#8be9fd'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.stroke();
    } else if (p.type==='life'){
      ctx.fillStyle='#50fa7b'; ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(-9,12); ctx.lineTo(9,12); ctx.closePath(); ctx.fill();
    }
    ctx.restore();
  });

  ctx.restore();
}

function updateUI(){
  document.getElementById('score').textContent = score;
  document.getElementById('lives').textContent = lives;
  document.getElementById('bombs').textContent = bombs;
  document.getElementById('shield').textContent = Math.max(0, shield);
  document.getElementById('time').textContent = Math.floor(gameTime/1000);
  document.getElementById('distance').textContent = Math.floor(distanceTraveled/100);

  const pm = document.getElementById('powerMeter');
  const pctx = pm.getContext('2d');
  pctx.fillStyle='#282a36'; pctx.fillRect(0,0,pm.width,pm.height);
  pctx.strokeStyle='#6272a4'; pctx.lineWidth=2; pctx.strokeRect(2,2,pm.width-4,pm.height-4);
  const perc = Math.max(0,shield)/100, w=(pm.width-8)*perc;
  pctx.fillStyle = shield>60 ? '#50fa7b' : shield>30 ? '#ffb86c' : '#ff5555';
  pctx.fillRect(4,4,w,pm.height-8);
}

/* ================== Audio ================== */
function playSound(freq, dur, type='square', vol=0.1){
  if (!audioContext) return;
  const osc=audioContext.createOscillator(), g=audioContext.createGain();
  osc.connect(g); g.connect(audioContext.destination);
  osc.frequency.setValueAtTime(freq, audioContext.currentTime); osc.type=type;
  g.gain.setValueAtTime(vol, audioContext.currentTime);
  g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime+dur);
  osc.start(audioContext.currentTime); osc.stop(audioContext.currentTime+dur);
}
function playLaserSound(){ const now=Date.now(); if (now-lastLaserTime>50){ playSound(800,0.05,'square',0.02); lastLaserTime=now; } }
function playExplosionSound(){ playSound(300,0.2,'sawtooth',0.08); setTimeout(()=>playSound(150,0.1,'sawtooth',0.06),50); }
function playBombExplosionSound(){ playSound(100,0.3,'sawtooth',0.1); setTimeout(()=>playSound(80,0.2,'sawtooth',0.08),100); }
function playPowerUpSound(){ playSound(400,0.1,'sine',0.06); setTimeout(()=>playSound(600,0.1,'sine',0.06),50); }

/* ================== Shop ================== */
function showShop(){
  gameState='shop'; lastShopTime=gameTime;
  document.getElementById('shopCredits').textContent = `Credits: ${credits}`;
  updateShopButtons();
  const s=document.getElementById('shopScreen'); s.style.display='block'; setTimeout(()=>s.classList.add('show'),10);
}
function updateShopButtons(){
  const c=document.getElementById('shopUpgrades'); c.innerHTML='';
  if (!upgrades.plasmaBlaster){
    c.innerHTML += `
      <div class="upgrade" id="plasmaBlaster">
        <h3>PLASMA BLASTER - 100 Credits</h3>
        <p>Larger purple projectiles, reduced fire rate, increased damage</p>
        <button onclick="purchaseUpgrade('plasmaBlaster')" ${credits>=100?'class="affordable"':''}>PURCHASE</button>
      </div>`;
  }
  if (upgrades.missiles<2){
    if (upgrades.missiles===0){
      c.innerHTML += `
        <div class="upgrade" id="missiles">
          <h3>MISSILES TIER 1 - 100 Credits</h3>
          <p>White rockets below blaster, slower but high damage</p>
          <button onclick="purchaseUpgrade('missiles')" ${credits>=100?'class="affordable"':''}>PURCHASE</button>
        </div>`;
    } else {
      c.innerHTML += `
        <div class="upgrade" id="missiles">
          <h3>MISSILES TIER 2 - 200 Credits</h3>
          <p>Second missile above blaster, same high damage</p>
          <button onclick="purchaseUpgrade('missiles')" ${credits>=200?'class="affordable"':''}>UPGRADE</button>
        </div>`;
    }
  }
  if (upgrades.homingMissiles<2){
    if (upgrades.homingMissiles===0){
      c.innerHTML += `
        <div class="upgrade" id="homingMissiles">
          <h3>HOMING MISSILES TIER 1 - 200 Credits</h3>
          <p>Red projectiles that auto-target strongest enemy</p>
          <button onclick="purchaseUpgrade('homingMissiles')" ${credits>=200?'class="affordable"':''}>PURCHASE</button>
        </div>`;
    } else {
      c.innerHTML += `
        <div class="upgrade" id="homingMissiles">
          <h3>HOMING MISSILES TIER 2 - 400 Credits</h3>
          <p>Second missile targets nearest healthy enemy</p>
          <button onclick="purchaseUpgrade('homingMissiles')" ${credits>=400?'class="affordable"':''}>UPGRADE</button>
        </div>`;
    }
  }
  if (!upgrades.bombCapacity){
    c.innerHTML += `
      <div class="upgrade" id="bombCapacity">
        <h3>BOMB CAPACITY UPGRADE - 350 Credits</h3>
        <p>Increase maximum bomb capacity from 9 to 50 bombs</p>
        <button onclick="purchaseUpgrade('bombCapacity')" ${credits>=350?'class="affordable"':''}>PURCHASE</button>
      </div>`;
  }
  // NEW: Torpedo upgrade
  if (!upgrades.torpedo){
    c.innerHTML += `
      <div class="upgrade" id="torpedoUpgrade">
        <h3>TORPEDO LAUNCHER - 300 Credits</h3>
        <p>Unlocks <b>T</b>: fires a large electric torpedo with heavy damage & small AoE</p>
        <button onclick="purchaseUpgrade('torpedo')" ${credits>=300?'class="affordable"':''}>PURCHASE</button>
      </div>`;
  }
}
function closeShop(){
  const s=document.getElementById('shopScreen');
  s.classList.remove('show');
  setTimeout(()=>{
    s.style.display='none';
    gameState='playing';
    lastShopTime = gameTime + 5000;
    startMainLoop();
  },300);
}
function purchaseUpgrade(which){
  let cost=0, ok=false;
  if (which==='plasmaBlaster'){ cost=100; ok=!upgrades.plasmaBlaster && credits>=cost; }
  else if (which==='missiles'){ cost = upgrades.missiles===0?100:200; ok=upgrades.missiles<2 && credits>=cost; }
  else if (which==='homingMissiles'){ cost = upgrades.homingMissiles===0?200:400; ok=upgrades.homingMissiles<2 && credits>=cost; }
  else if (which==='bombCapacity'){ cost=350; ok=!upgrades.bombCapacity && credits>=cost; }
  else if (which==='torpedo'){ cost=300; ok=!upgrades.torpedo && credits>=cost; }
  if (ok){
    credits -= cost;
    if (which==='plasmaBlaster') upgrades.plasmaBlaster=true;
    else if (which==='missiles') upgrades.missiles++;
    else if (which==='homingMissiles') upgrades.homingMissiles++;
    else if (which==='bombCapacity') upgrades.bombCapacity=true;
    else if (which==='torpedo') upgrades.torpedo=true;
    document.getElementById('shopCredits').textContent=`Credits: ${credits}`;
    updateShopButtons();
  }
}

/* ================== Scores ================== */
function loadHighScores(){ const s=localStorage.getItem('defenderHighScores'); highScores = s? JSON.parse(s):[]; }
function saveHighScores(){ localStorage.setItem('defenderHighScores', JSON.stringify(highScores)); }
function addHighScore(name,score){ highScores.push({name,score}); highScores.sort((a,b)=>b.score-a.score); highScores=highScores.slice(0,10); saveHighScores(); }
function isHighScore(score){ return highScores.length<10 || score>highScores[highScores.length-1].score; }

/* ================== Loop ================== */
function gameLoop(now){
  if (gameState!=='playing') return;
  let delta = now - lastTime; if (delta>100) delta=100; lastTime=now;
  gameTime += delta;

  const timeBonus = Math.min(gameTime/600000, 0.2);
  const powerupBonus = Math.min((bombs-3)*0.05, 0.1);
  gameSpeed = 1.0 + timeBonus + powerupBonus;
  delta *= gameSpeed;

  const dt = delta / 16.67;

  updatePlayer(dt, delta);
  updateBullets(dt, delta);
  updateEnemies(dt, delta);
  updatePowerUps(dt, delta);
  updateExplosions(delta);
  checkCollisions();
  spawnEnemy(delta);

  if (gameTime - lastShopTime > 30000) showShop();

  draw();
  updateUI();
  requestAnimationFrame(gameLoop);
}

/* ================== Init ================== */
function initAudio(){ /* deferred to interaction */ }
loadHighScores(); initTerrain(); initStars(); initAudio();
</script>
</body>
</html>
