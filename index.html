<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Defender - Space Shooter</title>
<style>
  body {
    margin: 0; padding: 0;
    background: #282a36; color: #f8f8f2;
    font-family: 'Courier New', monospace;
    display: flex; justify-content: center; align-items: center; height: 100vh;
  }
  #gameCanvas {
    border: 2px solid #44475a;
    background: linear-gradient(to bottom, #282a36 0%, #21222c 50%, #191a21 100%);
  }
  #ui { position: absolute; top: 10px; left: 10px; z-index: 10; }
  #topRight {
    position: absolute; top: 10px; right: 10px; z-index: 10; text-align: right;
    font-weight: bold;
  }
  #startScreen, #gameOverScreen {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    text-align: center; z-index: 20; background: rgba(40,42,54,0.9);
    padding: 20px; border: 2px solid #6272a4; border-radius: 8px; width: min(520px, 90vw);
  }
  #leaderboard, #gameOverLeaderboard {
    margin-top: 12px; text-align: left; max-height: 240px; overflow: auto;
    border: 1px solid #6272a4; padding: 8px; border-radius: 6px; background: rgba(20,21,28,0.4);
  }
  #leaderboard h3, #gameOverLeaderboard h3 { margin: 0 0 8px 0; }
  input { background: #44475a; border: 1px solid #6272a4; color: #f8f8f2; padding: 5px; margin: 10px; }
  button { background: #44475a; border: 1px solid #6272a4; color: #f8f8f2; padding: 10px 20px; cursor: pointer; }
  button:hover { background: #6272a4; }
  button.affordable { background: #50fa7b; color: #282a36; }
  button.affordable:hover { background: #7bfaad; }
  #shopScreen {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    text-align: center; z-index: 20; background: rgba(40,42,54,0.95);
    padding: 20px; border: 2px solid #6272a4; border-radius: 8px;
    opacity: 0; transition: opacity 0.3s ease-in-out; display: none; width: min(640px, 95vw);
  }
  #shopScreen.show { opacity: 1; }
  .upgrade { text-align: left; margin: 12px 0; padding: 10px; border: 1px dashed #6272a4; border-radius: 6px; }
</style>
</head>
<body>
<canvas id="gameCanvas" width="1200" height="600"></canvas>

<div id="ui">
  <div>Score: <span id="score">0</span></div>
  <div>Lives: <span id="lives">3</span></div>
  <div>Bombs: <span id="bombs">3</span></div>
  <div>Shield: <span id="shield">100</span>%</div>
  <div>Time: <span id="time">0</span>s</div>
  <div>Parsecs: <span id="distance">0</span></div>
  <div style="margin-top: 10px;">
    <div style="color: #50fa7b; font-size: 12px;">POWER</div>
    <canvas id="powerMeter" width="100" height="20" style="border: 1px solid #6272a4; background: #282a36;"></canvas>
  </div>
</div>

<div id="topRight">
  Ship Lv <span id="shipLevel">0</span>
</div>

<div id="startScreen">
  <h1>DEFENDER</h1>
  <p>Protect the planet from alien invaders!</p>
  <input type="text" id="playerName" placeholder="Enter your name" maxlength="20" />
  <br />
  <button onclick="startGame()">START GAME</button>
  <br /><br />
  <p>Controls:</p>
  <p>Arrow Keys: Move | Spacebar: Laser | B: Bomb | T: Torpedo (if purchased)</p>

  <div id="leaderboard">
    <h3>High Scores</h3>
    <ol id="highScoreList"></ol>
  </div>
</div>

<div id="gameOverScreen" style="display: none;">
  <h1>GAME OVER</h1>
  <p id="finalScore"></p>
  <p id="playerNameDisplay"></p>
  <div id="gameOverLeaderboard">
    <h3>High Scores</h3>
    <ol id="gameOverScores"></ol>
  </div>
  <button onclick="resetGame()">PLAY AGAIN</button>
</div>

<div id="shopScreen">
  <h1>UPGRADE SHOP</h1>
  <p id="shopCredits">Credits: 0</p>
  <div id="shopUpgrades"></div>
  <button onclick="closeShop()">CONTINUE GAME</button>
</div>

<script>
/* ================== Canvas & Core ================== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState = 'start';
let playerName = '';
let gameTime = 0;     // ms since run started
let lastTime  = 0;    // last RAF timestamp
let score = 0, lives = 3, bombs = 3, shield = 100;
let lastBossTime = 0;
let cameraX = 0;
let distanceTraveled = 0;
let highScores = [];
let gameSpeed = 1.0;

/* ================== Upgrades (tiers 0..3) ================== */
let upgrades = {
  plasma: 0,
  missiles: 0,
  homing: 0,
  bombCapacity: 0,
  torpedo: 0
};
function getShipLevel(){ return upgrades.plasma + upgrades.missiles + upgrades.homing + upgrades.bombCapacity + upgrades.torpedo; }

/* ================== Audio ================== */
let audioContext = null;
let lastLaserTime = 0;
function ensureAudio(){ if(!audioContext){ try{ audioContext=new (window.AudioContext||window.webkitAudioContext)(); }catch(_){} } }
document.addEventListener('keydown', ensureAudio, { once:true });
document.addEventListener('click', ensureAudio, { once:true });

/* ================== Input ================== */
let keys = {};
let shootTimerMs = 0;
let homingMissileTimerMs = 0;
let torpedoTimerMs = 0; // cooldown timer
const FRAME_MS = 16.67;
const baseShootDelayMs = 8 * FRAME_MS;
function plasmaShootDelay(){ return baseShootDelayMs * (upgrades.plasma ? [1.5, 1.35, 1.2][upgrades.plasma-1] : 1.0); }
const homingMissileDelayMs = 24 * FRAME_MS;
function torpedoCooldownMs(){ return [Infinity, 1400, 1100, 900][upgrades.torpedo]; }

document.addEventListener('keydown', (e)=>{
  keys[e.key] = true;
  if (e.key === ' ') e.preventDefault();
  if (e.key && e.key.toLowerCase() === 'b' && gameState === 'playing') dropBomb();
  if (e.key && e.key.toLowerCase() === 't' && gameState === 'playing') fireTorpedo();
  if (e.key === 'Enter'){
    if (gameState === 'start') startGame();
    else if (gameState === 'shop') closeShop();
  }
});
document.addEventListener('keyup', (e)=>{ keys[e.key] = false; });

/* ================== Entities & World ================== */
/* --- Ship tuned down slightly for smoother feel --- */
let player = {
  x: 100, y: 300, width: 20, height: 16,
  vx: 0, vy: 0,
  maxSpeed: 150,      // was 180
  accel: 300          // was 360
};

let bullets = [];
let enemies = [];
let explosions = [];
let powerUps = [];
let stars = [];
let terrain = [];

let terrainGeneratedUpTo = 0;

/* ------- Terrain ------- */
function initTerrain(){ terrain=[]; generateTerrainSegment(0, canvas.width*3); }
function generateTerrainSegment(startX, endX){
  for (let x=startX; x<endX; x+=10){
    let h = 450 + Math.sin(x*0.02)*20 + Math.sin(x*0.005)*40;
    if (Math.random()<0.1){
      let w = 40 + Math.random()*60, d = 20 + Math.random()*30;
      for (let i=0;i<w;i+=10){
        if (x+i < endX){
          let ch = h + Math.sin((i/w)*Math.PI)*d;
          terrain.push({x:x+i, y:ch});
        }
      }
      x += w;
    } else {
      terrain.push({x, y:h});
    }
  }
  terrainGeneratedUpTo = endX;
}
function getTerrainHeight(x){
  if (terrain.length < 2) return 450;
  let lo=0, hi=terrain.length-2;
  while (lo<=hi){
    const mid=(lo+hi)>>1;
    const ax=terrain[mid].x, bx=terrain[mid+1].x;
    if (x<ax) hi=mid-1;
    else if (x>bx) lo=mid+1;
    else {
      const t=(x-ax)/((bx-ax)||1);
      return terrain[mid].y*(1-t)+terrain[mid+1].y*t;
    }
  }
  return 450;
}

/* ------- Stars ------- */
function initStars(){
  stars = [];
  for (let i=0;i<140;i++){ // a few more stars
    stars.push({
      x: Math.random()*canvas.width + cameraX,
      y: Math.random()*canvas.height*0.8,
      brightness: Math.random()
    });
  }
}

/* ================== Game Flow ================== */
function startMainLoop(){ lastTime=performance.now(); requestAnimationFrame(gameLoop); }

function startGame(){
  playerName = document.getElementById('playerName').value || 'Anonymous';
  document.getElementById('startScreen').style.display='none';
  gameState='playing';
  resetGameVars();
  initTerrain(); initStars();
  renderHighScores('highScoreList');
  startMainLoop();
}
function resetGameVars(){
  gameTime=0; score=0; lives=3; bombs=3; shield=100;
  lastBossTime=0; shootTimerMs=0; homingMissileTimerMs=0; torpedoTimerMs=0;
  player.x=100; player.y=300; player.vx=0; player.vy=0;
  bullets=[]; enemies=[]; explosions=[]; powerUps=[];
  cameraX=0; distanceTraveled=0; credits=0; lastShopTime=0;
  lastSandwormTime = -1;

  upgrades = { plasma:0, missiles:0, homing:0, bombCapacity:0, torpedo:0 };
  updateShipLevelUI();
}
function resetGame(){
  document.getElementById('gameOverScreen').style.display='none';
  document.getElementById('startScreen').style.display='block';
  renderHighScores('highScoreList');
  gameState='start';
}

/* ================== Weapons ================== */
function shoot(){
  // Primary
  if (upgrades.plasma>0){
    const widths = [20, 24, 28];
    const damages = [2, 3, 4];
    const speeds  = [8, 9, 10];
    const i = upgrades.plasma-1;
    bullets.push({ x:player.x+player.width, y:player.y+player.height/2, vx:speeds[i], vy:0, type:'plasma', width:widths[i], height:6, damage:damages[i] });
  } else {
    bullets.push({ x:player.x+player.width, y:player.y+player.height/2, vx:12, vy:0, type:'laser', width:12, height:3, damage:1 });
  }

  // Missiles â€” now angled slightly downward out of the nose
  if (upgrades.missiles>=1){
    const dmg=[0,3,4,5][upgrades.missiles];
    const add=upgrades.missiles;
    const lanes=[-8,8,0];
    for (let k=0;k<add;k++){
      const off=lanes[k];
      // noticeable downward angle; lower lane angles a bit more
      const vyDown = 2 + (off===-8 ? 0.6 : off===0 ? 0.3 : 0.1);
      bullets.push({
        x: player.x+player.width,
        y: player.y+player.height/2 + off,
        vx: 6.2, vy: vyDown,               // <-- angled down
        type:'missile', width:8, height:4, damage:dmg, tier:k+1
      });
    }
  }

  playLaserSound();
}

function shootHomingMissiles(){
  const tier = upgrades.homing;
  if (tier<=0) return;

  const count = tier; // 1..3
  const dmg = [0,2,3,4][tier];
  const targets = [];

  const strongest = enemies.slice().sort((a,b)=>b.health-a.health)[0];
  if (strongest) targets.push(strongest);

  const healthy = enemies.filter(e=>e.health===e.maxHealth || e.health>5);
  const nearestHealthy = healthy.slice().sort((a,b)=>{
    const da=Math.hypot(a.x-player.x, a.y-player.y);
    const db=Math.hypot(b.x-player.x, b.y-player.y);
    return da-db;
  })[0];
  if (nearestHealthy && !targets.includes(nearestHealthy)) targets.push(nearestHealthy);

  const nearestOverall = enemies.slice().sort((a,b)=>{
    const da=Math.hypot(a.x-player.x, a.y-player.y);
    const db=Math.hypot(b.x-player.x, b.y-player.y);
    return da-db;
  })[0];
  if (nearestOverall && !targets.includes(nearestOverall)) targets.push(nearestOverall);

  for (let n=0;n<count;n++){
    const target = targets[n] || strongest || nearestOverall;
    if (!target) break;
    let dx = (target.x+target.width/2) - (player.x+player.width);
    let dy = (target.y+target.height/2) - (player.y+player.height/2);
    let d = Math.hypot(dx,dy)||1, speed=5;
    const yOff = [-8, 8, 0][n] || 0;
    bullets.push({ x:player.x+player.width, y:player.y+player.height/2+yOff, vx:(dx/d)*speed, vy:(dy/d)*speed, type:'homing', width:6, height:6, damage:dmg, target });
  }
}

function dropBomb(){
  if (bombs>0){
    bombs--;
    const bombDmg=[3,4,5,6][upgrades.bombCapacity];
    bullets.push({ x:player.x, y:player.y+player.height, vx:0, vy:5, type:'bomb', width:8, height:8, damage:bombDmg });
  }
}

function fireTorpedo(){
  const tier = upgrades.torpedo;
  if (tier<=0 || gameState!=='playing') return;
  if (torpedoTimerMs>0) return;
  torpedoTimerMs = torpedoCooldownMs();
  const dmg=[0,12,16,20][tier];
  const speed=[0,16,18,20][tier];
  bullets.push({ x:player.x+player.width, y:player.y+player.height/2, vx:speed, vy:0, type:'torpedo', width:26+2*(tier-1), height:10+(tier-1), damage:dmg, pierce:tier-1 });
}

/* ================== Spawning ================== */
// Progressive saucer scaling (every 35s)
function getSaucerTier(){ return Math.floor(gameTime / 35000); }
function saucerScaleForTier(tier){
  const sizeUp = 1 + (0.02 + Math.random()*0.01) * tier;
  const hpUp = 1 + (0.20 + Math.random()*0.10) * tier;
  const wepUp = 1 + (0.02 + Math.random()*0.08) * tier;
  return { sizeUp, hpUp, wepUp };
}

let credits = 0;
let lastShopTime = 0;
let lastSandwormTime = -1;
const SANDWORM_FIRST_MS = 180000; // ~3 minutes
const SANDWORM_COOLDOWN_MS = 90000;

// NEW: Bouncer enemy (zig-zag, wall bounces)
function spawnBouncer(spawnX){
  const size = 22;
  const y = 60 + Math.random() * (canvas.height - 180);
  enemies.push({
    type:'bouncer',
    x: spawnX, y,
    width: size, height: size,
    vx: -2.3,                   // deliberately slower
    vy: (Math.random()<0.5? -1:1) * 1.4, // gentle vertical drift
    health: 6 + Math.floor(gameTime/60000),
    maxHealth: 6 + Math.floor(gameTime/60000),
    shootTimerMs: 0
  });
}

function spawnEnemy(deltaTime){
  const t = gameTime;

  // MORE ENEMIES: increase spawn rate noticeably
  const basePerSec = Math.min(0.08 + t * 0.0000012, 4.0); // was ~0.03..2.4
  const p = (basePerSec/1000) * deltaTime;

  // Dinosaur cap
  const dinos = enemies.filter(e=>e.type==='dinosaur').length;
  const maxDinos = t<15000?0 : t<45000?2 : t<90000?3 : 4;

  if (Math.random() < p){
    // include new 'bouncer' sometimes
    let pool = ['fighter','bomber','dinosaur','bouncer','fighter','fighter'];
    let type = pool[Math.floor(Math.random()*pool.length)];
    if (type==='dinosaur' && dinos>=maxDinos) type = Math.random()<0.5 ? 'fighter' : 'bouncer';

    const spawnX = cameraX + canvas.width + 50;

    if (type==='bouncer'){ spawnBouncer(spawnX); }
    else {
      let enemyHealth = (type==='dinosaur') ? 8 + Math.floor(t/45000) : 1 + Math.floor(t/60000);
      let w = (type==='dinosaur')?45:25;
      let h = (type==='dinosaur')?35:20;

      let weaponScale = 1, tier = 0;
      if (type==='fighter'){
        tier = getSaucerTier();
        const { sizeUp, hpUp, wepUp } = saucerScaleForTier(tier);
        w = Math.round(w * sizeUp);
        h = Math.round(h * sizeUp);
        enemyHealth = Math.ceil(enemyHealth * hpUp);
        weaponScale = wepUp;
      }

      enemies.push({
        type, x: spawnX,
        y: type==='dinosaur' ? getTerrainHeight(spawnX)-35 : Math.random()*(canvas.height-200),
        width: (type==='boss')?80 : w,
        height:(type==='boss')?60 : h,
        vx: -2.4 - Math.random()*1 - Math.floor(t/60000)*0.15, // slightly faster flow overall
        vy: 0,
        health: enemyHealth,
        maxHealth: enemyHealth,
        shootTimerMs: 0,
        walkTimer: type==='dinosaur'? Math.random()*100 : 0,
        moveTimer: 0,
        tier,
        weaponScale
      });
    }
  }

  // Legacy mini-boss
  const bossInterval = Math.max(20000 - Math.floor(t/60000)*3000, 10000);
  if (t - lastBossTime > bossInterval){
    const spawnX = cameraX + canvas.width + 100;
    const bossHealth = 10 + Math.floor(t/45000)*5;
    enemies.push({
      type:'boss', x:spawnX,
      y: canvas.height/2 - 40 + (Math.random()*120 - 60),
      width:80, height:60,
      vx: -1 - Math.floor(t/120000)*0.15, vy:0,
      health: bossHealth, maxHealth: bossHealth,
      shootTimerMs: 0, moveTimer: 0, tier:0, weaponScale:1.0
    });
    lastBossTime = t;
  }

  // Sand Worm boss
  if ((t >= SANDWORM_FIRST_MS) && (lastSandwormTime < 0 || t - lastSandwormTime >= SANDWORM_COOLDOWN_MS)){
    spawnSandworm();
    lastSandwormTime = t;
  }
}

function spawnSandworm(){
  const hp = 300 + Math.floor(gameTime/60000)*80;
  enemies.push({
    type: 'sandworm',
    x: cameraX + canvas.width/2, y: canvas.height - 80,
    width: 120, height: 40,
    vx: 0, vy: 0,
    health: hp, maxHealth: hp,
    tParam: 0, speedPerSec: 0.08,
    shootTimerMs: 0,
    weaponScale: 1 + Math.min(gameTime/600000, 0.5),
    segmentCount: 8
  });
}

/* ================== Power-ups ================== */
function spawnPowerUp(x,y,isBoss){
  let types = ['bombs','shield']; if (isBoss) types.push('life');
  let type = types[Math.floor(Math.random()*types.length)];
  powerUps.push({
    x,y, vx:0, vy:0, type,
    timerMs:0, hoverTimerMs:0,
    hoverDurationMs: (480+Math.random()*240)*FRAME_MS,
    width:16, height:16
  });
}

/* ================== Updates ================== */
function updatePlayer(dt, deltaTime){
  const acc = player.accel * dt;
  if (keys['ArrowLeft'])  player.vx = Math.max(player.vx - acc, -player.maxSpeed);
  if (keys['ArrowRight']) player.vx = Math.min(player.vx + acc,  player.maxSpeed);
  if (keys['ArrowUp'])    player.vy = Math.max(player.vy - acc, -player.maxSpeed);
  if (keys['ArrowDown'])  player.vy = Math.min(player.vy + acc,  player.maxSpeed);

  if (keys[' '] && gameState==='playing'){
    shootTimerMs += deltaTime;
    homingMissileTimerMs += deltaTime;
    const currDelay = plasmaShootDelay();
    if (shootTimerMs>=currDelay){ shoot(); shootTimerMs=0; }
    if (upgrades.homing>0 && homingMissileTimerMs>=homingMissileDelayMs){ shootHomingMissiles(); homingMissileTimerMs=0; }
  } else { shootTimerMs=0; homingMissileTimerMs=0; }

  if (upgrades.torpedo>0 && torpedoTimerMs>0) torpedoTimerMs = Math.max(0, torpedoTimerMs - deltaTime);

  // slightly stronger smoothing (less jitter)
  const damp = Math.pow(0.88, dt*60); // was 0.92
  player.vx *= damp; player.vy *= damp;

  if (player.vx>0) distanceTraveled += player.vx * dt;

  player.x += player.vx * dt;
  player.y += player.vy * dt;

  cameraX = player.x - canvas.width/2;

  if (cameraX + canvas.width*2 > terrainGeneratedUpTo){
    generateTerrainSegment(terrainGeneratedUpTo, terrainGeneratedUpTo + canvas.width);
  }
  if (player.y<0) player.y=0;
  if (player.y>canvas.height-player.height) player.y=canvas.height-player.height;
}

function updateBullets(dt, deltaTime){
  for (let i=bullets.length-1;i>=0;i--){
    let b = bullets[i];

    // Enemy homing lifetime (prevent eternal orbit)
    if (b.type==='enemyHoming'){
      b.lifeMs = (b.lifeMs||0) + deltaTime;
      if (!b.maxLifeMs) b.maxLifeMs = 4000 + Math.random()*3000;
      if (b.lifeMs >= b.maxLifeMs){ bullets.splice(i,1); continue; }
    }

    // Homing adjust
    if (b.type==='homing' && b.target && enemies.includes(b.target)){
      let t=b.target; let dx=t.x+t.width/2-b.x; let dy=t.y+t.height/2-b.y;
      let dist=Math.hypot(dx,dy)||1; const speed=5, k=0.1;
      let tvx=(dx/dist)*speed, tvy=(dy/dist)*speed;
      b.vx += (tvx-b.vx)*k; b.vy += (tvy-b.vy)*k;
      let s=Math.hypot(b.vx,b.vy)||1; b.vx=(b.vx/s)*speed; b.vy=(b.vy/s)*speed;
    }
    if (b.type==='enemyHoming' && b.target){
      let t=b.target; let dx=t.x+t.width/2-b.x; let dy=t.y+t.height/2-b.y;
      let dist=Math.hypot(dx,dy)||1; const speed=4.5, k=0.08;
      let tvx=(dx/dist)*speed, tvy=(dy/dist)*speed;
      b.vx += (tvx-b.vx)*k; b.vy += (tvy-b.vy)*k;
      let s=Math.hypot(b.vx,b.vy)||1; b.vx=(b.vx/s)*speed; b.vy=(b.vy/s)*speed;
    }

    b.x += b.vx * dt;
    b.y += b.vy * dt;

    // Offscreen cull
    if (b.x > cameraX+canvas.width+100 || b.x < cameraX-100 || b.y > canvas.height+50 || b.y < -50){
      bullets.splice(i,1); continue;
    }

    if (b.type==='bomb'){
      if (b.y > getTerrainHeight(b.x)-10){
        createExplosion(b.x,b.y,60); playBombExplosionSound();
        enemies.forEach(e=>{
          let d=Math.hypot(e.x+e.width/2-b.x, e.y+e.height/2-b.y);
          if (d<80) e.health -= b.damage || 3;
        });
        bullets.splice(i,1); continue;
      }
    }

    if (b.type==='torpedo'){
      b.y += Math.sin((b.x+b.y)*0.05)*0.4;
    }
  }
}

function updateEnemies(dt, deltaTime){
  for (let i=enemies.length-1;i>=0;i--){
    let e = enemies[i];
    e.x += e.vx * dt; e.y += e.vy * dt;

    if (e.type==='boss'){
      e.moveTimer += deltaTime;
      e.vy = Math.sin(e.moveTimer*0.05*0.06) * 120 * dt;
    }

    if (e.type==='dinosaur'){
      e.walkTimer += deltaTime*0.06;
      let th = getTerrainHeight(e.x+e.width/2);
      let targetY = th - e.height;
      let dy = targetY - e.y;
      e.vy = dy * 0.6 * dt; e.y += Math.sin(e.walkTimer*0.3)*0.5;
      if (Math.random()<0.005*dt*60) e.vx = -e.vx;
      if (e.y<targetY-10) e.y=targetY-10;
      if (e.y>targetY+10) e.y=targetY+10;
    }

    // Bouncer: bounce off vertical bounds and "ceiling/floor" edges
    if (e.type==='bouncer'){
      const top = 40, bottom = canvas.height - 80;
      if (e.y < top){ e.y = top; e.vy = Math.abs(e.vy); }
      if (e.y > bottom){ e.y = bottom; e.vy = -Math.abs(e.vy); }
      // slight horizontal wobble to feel alive
      e.vx += (Math.sin((e.x+e.y)*0.01) * 0.06) * dt * 60;
      // clamp to keep it slow-ish
      if (e.vx < -3.2) e.vx = -3.2;
      if (e.vx > -1.2) e.vx = -1.2;
      // occasional shot
      e.shootTimerMs = (e.shootTimerMs||0)+deltaTime;
      if (e.shootTimerMs > 1400 + Math.random()*600){
        e.shootTimerMs = 0;
        bullets.push({ x:e.x, y:e.y+e.height/2, vx:-3.2, vy:0.6, type:'enemy', width:6, height:6, damage:10 });
      }
    }

    // Sandworm perimeter patrol
    if (e.type==='sandworm'){
      e.tParam += e.speedPerSec * (deltaTime/1000); if (e.tParam>1) e.tParam-=1;
      const m = 30;
      const left = cameraX + m, right = cameraX + canvas.width - m;
      const top = m, bottom = canvas.height - m;
      const t = e.tParam;
      let px, py;
      if (t < 0.25){ const u=t/0.25; px=left+(right-left)*u; py=top; }
      else if (t < 0.5){ const u=(t-0.25)/0.25; px=right; py=top+(bottom-top)*u; }
      else if (t < 0.75){ const u=(t-0.5)/0.25; px=right-(right-left)*u; py=bottom; }
      else { const u=(t-0.75)/0.25; px=left; py=bottom-(bottom-top)*u; }
      e.x = px - e.width/2; e.y = py - e.height/2;

      e.shootTimerMs += deltaTime;
      const sd = 900 - Math.min(gameTime/6000, 500);
      if (e.shootTimerMs > sd){
        e.shootTimerMs = 0;
        const headX = e.x + e.width/2, headY = e.y + e.height/2;
        for (let k=0;k<2;k++){
          let dx = (player.x+player.width/2) - headX;
          let dy = (player.y+player.height/2) - headY;
          let d = Math.hypot(dx,dy)||1;
          const sp = 4.8 + Math.random()*0.8;
          bullets.push({ x: headX, y: headY, vx:(dx/d)*sp, vy:(dy/d)*sp, type:'enemyHoming', width:6, height:6, target:player, damage: Math.round(10 * e.weaponScale) });
        }
      }
    }

    // Enemy shooting cadence (fighters scale by weaponScale)
    e.shootTimerMs = (e.shootTimerMs||0) + deltaTime;
    let sd;
    if (gameTime<30000) sd=5000+Math.random()*3300;
    else if (gameTime<60000) sd=4000+Math.random()*2000;
    else if (gameTime<120000) sd=3000+Math.random()*1500;
    else sd=2000+Math.random()*1000;

    if (e.shootTimerMs > sd && e.type!=='sandworm' && e.type!=='bouncer'){
      if (e.type==='dinosaur'){
        let dx=player.x+player.width/2-e.x, dy=player.y+player.height/2-e.y;
        let d=Math.hypot(dx,dy)||1; let sp=4.5;
        bullets.push({ x:e.x, y:e.y+e.height/2, vx:(dx/d)*sp, vy:(dy/d)*sp, type:'enemyHoming', width:5, height:5, target:player, damage:10 });
      } else {
        const baseSpeed = (e.type==='fighter') ? 3.2*e.weaponScale : 3.2;
        const dmg = (e.type==='fighter') ? Math.round(10 * e.weaponScale) : 10;
        bullets.push({ x:e.x, y:e.y+e.height/2, vx:-baseSpeed, vy:0, type:'enemy', width:6, height:6, damage:dmg });
      }
      e.shootTimerMs = 0;
    }

    // Cull / death
    if (e.x < cameraX-140 || e.health<=0){
      if (e.health<=0){
        createExplosion(e.x+e.width/2, e.y+e.height/2, e.type==='boss'||e.type==='sandworm'? 90:40);
        playExplosionSound();
        let enemyCredits =
          e.type==='sandworm' ? 120 :
          e.type==='boss' ? 50 :
          e.type==='dinosaur' ? 10 :
          e.type==='bomber' ? 5 :
          e.type==='bouncer' ? 6 : 1;
        credits += enemyCredits;
        score += e.type==='sandworm' ? 1200 :
                 e.type==='boss' ? 500 :
                 e.type==='dinosaur' ? 150 :
                 e.type==='bouncer' ? 120 : 100;
        if (Math.random() < (e.type==='boss'||e.type==='sandworm' ? 1 : 0.3)) spawnPowerUp(e.x, e.y, (e.type==='boss'||e.type==='sandworm'));
      }
      enemies.splice(i,1);
    }
  }
}

function updatePowerUps(dt, deltaTime){
  for (let i=powerUps.length-1;i>=0;i--){
    let p=powerUps[i]; p.hoverTimerMs+=deltaTime;
    if (p.hoverTimerMs >= p.hoverDurationMs) p.vy = 120*dt;
    let dx=(player.x+player.width/2)-(p.x+p.width/2);
    let dy=(player.y+player.height/2)-(p.y+p.height/2);
    let dist=Math.hypot(dx,dy)||1;
    if (dist<150){
      let strength=Math.max(0.3,2 - dist/75);
      let ang=Math.atan2(dy,dx);
      p.vx += Math.cos(ang)*strength*6*dt;
      p.vy += Math.sin(ang)*strength*6*dt;
      p.vx *= Math.pow(0.9, dt*60); p.vy *= Math.pow(0.9, dt*60);
    } else {
      p.vx *= Math.pow(0.95, dt*60); p.vy *= Math.pow(0.95, dt*60);
    }
    p.x += p.vx*dt; p.y += p.vy*dt; p.timerMs=(p.timerMs||0)+deltaTime;
    if (p.y>canvas.height || p.timerMs>10000){ powerUps.splice(i,1); continue; }
    if (checkCollision(player,p)){
      if (p.type==='bombs'){ const caps=[9,20,35,50]; const cap=caps[upgrades.bombCapacity]; bombs = Math.min(bombs+3, cap); }
      if (p.type==='shield'){ shield = Math.min(shield+25, 100); }
      if (p.type==='life'){ lives++; }
      score += 50; playPowerUpSound(); powerUps.splice(i,1);
    }
  }
}

function updateExplosions(deltaTime){
  for (let i=explosions.length-1;i>=0;i--){
    let ex=explosions[i]; ex.timerMs += deltaTime;
    if (ex.timerMs >= ex.maxTimerMs) explosions.splice(i,1);
  }
}

/* ================== Collisions ================== */
function checkCollision(a,b){
  return a.x < b.x + b.width && a.x + a.width > b.x &&
         a.y < b.y + b.height && a.y + a.height > b.y;
}

function checkCollisions(){
  // Player bullets vs enemies
  for (let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    if (b.type==='enemy' || b.type==='enemyHoming') continue;

    for (let j=enemies.length-1;j>=0;j--){
      let e=enemies[j];
      if (checkCollision(b,e)){
        e.health -= b.damage || 1;
        if (b.type==='torpedo'){
          if (b.pierce>0){ b.pierce--; }
          else {
            createExplosion(b.x,b.y,70);
            enemies.forEach(en=>{
              const d=Math.hypot(en.x+en.width/2-b.x, en.y+en.height/2-b.y);
              if (d<85) en.health -= 6 + 2*(upgrades.torpedo-1);
            });
            bullets.splice(i,1);
          }
        } else if (b.type==='laser' || b.type==='plasma' || b.type==='missile' || b.type==='homing'){
          bullets.splice(i,1);
        }
        createExplosion(b.x,b.y,25);
        break;
      }
    }
  }

  // Enemy bullets vs player
  for (let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    if (b.type!=='enemy' && b.type!=='enemyHoming') continue;
    if (checkCollision(b, player)){
      shield -= (b.damage || 10);
      bullets.splice(i,1);
      createExplosion(player.x+player.width/2, player.y+player.height/2, 30);
    }
  }

  // Enemies vs player
  enemies.forEach(e=>{
    if (checkCollision(e,player)){
      shield -= 20;
      createExplosion(player.x+player.width/2, player.y+player.height/2, 40);
      e.health = 0;
    }
  });

  if (shield<=0){
    lives--; shield=100;
    if (lives<=0) gameOver();
  }
}

/* ================== FX & UI ================== */
function createExplosion(x,y,size){
  explosions.push({ x,y,size, timerMs:0, maxTimerMs: 20*FRAME_MS });
}

function gameOver(){
  gameState='gameOver';
  const parsecs = Math.floor(distanceTraveled/100);
  const finalScore = score + Math.floor(gameTime/1000)*10 + parsecs*5;
  addHighScore(playerName, finalScore);
  document.getElementById('finalScore').textContent=`Final Score: ${finalScore}`;
  document.getElementById('playerNameDisplay').textContent=`Player: ${playerName} - ${parsecs} Parsecs Traveled`;
  renderHighScores('gameOverScores');
  document.getElementById('gameOverScreen').style.display='block';
}

function draw(){
  ctx.fillStyle='#282a36'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.translate(-cameraX,0);

  // stars parallax
  const parallax=0.4;
  ctx.fillStyle='#8be9fd';
  stars.forEach(s=>{
    ctx.globalAlpha = s.brightness*1.0;
    const sx = s.x + cameraX*(1-parallax);
    ctx.fillRect(sx, s.y, 1, 1);
  });
  ctx.globalAlpha = 1;

  // terrain
  ctx.strokeStyle='#ffb86c'; ctx.lineWidth=2; ctx.beginPath();
  terrain.forEach((p,i)=>{ i===0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y); }); ctx.stroke();
  ctx.fillStyle='#bd93f9'; ctx.beginPath();
  terrain.forEach((p,i)=>{ i===0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y); });
  ctx.lineTo(canvas.width+cameraX,canvas.height); ctx.lineTo(cameraX,canvas.height); ctx.closePath(); ctx.fill();

  // player
  ctx.save(); ctx.translate(player.x+player.width/2, player.y+player.height/2);
  ctx.fillStyle='#50fa7b'; ctx.beginPath();
  ctx.moveTo(15,0); ctx.lineTo(-10,-8); ctx.lineTo(-5,0); ctx.lineTo(-10,8); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#ff5555'; ctx.beginPath();
  ctx.moveTo(-5,-3); ctx.lineTo(-15,0); ctx.lineTo(-5,3); ctx.closePath(); ctx.fill();
  ctx.restore();

  // enemies
  enemies.forEach(e=>{
    ctx.save(); ctx.translate(e.x, e.y);
    if (e.type==='dinosaur'){
      ctx.fillStyle='#50fa7b'; ctx.fillRect(8,15,16,12); ctx.fillRect(20,10,8,8);
      ctx.fillRect(10,27,2,8); ctx.fillRect(18,27,2,8);
      ctx.fillStyle='#ffffff'; ctx.fillRect(22,12,1,1); ctx.fillRect(25,12,1,1);
      ctx.fillStyle='#50fa7b'; ctx.fillRect(8,12,2,3); ctx.fillRect(12,10,2,5); ctx.fillRect(16,8,2,7);
    } else if (e.type==='fighter'){
      ctx.fillStyle='#ff5555';
      ctx.fillRect(6,8,Math.max(12, e.width-13),8);
      ctx.fillRect(2,10,4,4); ctx.fillRect( (6+Math.max(12, e.width-13)),10,4,4);
      ctx.fillStyle='#ffb86c'; ctx.fillRect(10,6,4,4);
    } else if (e.type==='bomber'){
      ctx.fillStyle='#ffb86c'; ctx.fillRect(8,12,8,6);
      ctx.fillRect(4,14,4,2); ctx.fillRect(16,14,4,2);
      ctx.fillRect(10,8,4,4);
    } else if (e.type==='boss'){
      ctx.fillStyle='#ff5555'; ctx.fillRect(10,15,20,15);
      ctx.fillStyle='#ffffff'; ctx.fillRect(14,18,2,2); ctx.fillRect(24,18,2,2);
      ctx.fillStyle='#000000'; ctx.fillRect(16,25,8,2);
      ctx.fillStyle='#ff5555'; ctx.fillRect(12,10,1,5); ctx.fillRect(27,10,1,5);
    } else if (e.type==='sandworm'){
      const seg = e.segmentCount||8;
      for (let s=0;s<seg;s++){
        const r = 12 - s*1.2;
        ctx.fillStyle = s===0 ? '#d2b48c' : '#bda16f';
        ctx.beginPath(); ctx.arc(e.width/2 - s*14, e.height/2, Math.max(4,r), 0, Math.PI*2); ctx.fill();
      }
      ctx.fillStyle='#000'; ctx.fillRect(e.width/2-4, e.height/2-4, 3,3);
    } else if (e.type==='bouncer'){
      // simple diamond that feels "bouncy"
      ctx.fillStyle='#8be9fd';
      ctx.beginPath();
      ctx.moveTo(e.width/2, 0);
      ctx.lineTo(e.width, e.height/2);
      ctx.lineTo(e.width/2, e.height);
      ctx.lineTo(0, e.height/2);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  });

  // bullets
  bullets.forEach(b=>{
    if (b.type==='laser'){
      ctx.strokeStyle='#8be9fd'; ctx.lineWidth=3; ctx.beginPath();
      ctx.moveTo(b.x,b.y); ctx.lineTo(b.x+12,b.y); ctx.stroke();
      ctx.strokeStyle='#ffffff'; ctx.lineWidth=1; ctx.beginPath();
      ctx.moveTo(b.x,b.y); ctx.lineTo(b.x+12,b.y); ctx.stroke();
    } else if (b.type==='plasma'){
      ctx.fillStyle='#bd93f9'; ctx.fillRect(b.x, b.y-3, b.width, b.height);
      ctx.strokeStyle='#ff79c6'; ctx.lineWidth=2; ctx.strokeRect(b.x, b.y-3, b.width, b.height);
    } else if (b.type==='missile'){
      ctx.fillStyle='#ffffff'; ctx.fillRect(b.x, b.y-2, b.width, b.height);
      ctx.fillStyle='#ff5555'; ctx.fillRect(b.x-4, b.y-1, 4, 2);
    } else if (b.type==='homing'){
      ctx.fillStyle='#ff5555'; ctx.fillRect(b.x, b.y-b.height/2, b.width, b.height);
      ctx.fillStyle='#ffffff'; ctx.fillRect(b.x-b.width/2, b.y-b.height/4, b.width/2, b.height/2);
      ctx.strokeStyle='#ff5555'; ctx.lineWidth=1; ctx.globalAlpha=0.5;
      ctx.beginPath(); ctx.arc(b.x+b.width/2, b.y, b.width*1.5, 0, Math.PI*2); ctx.stroke();
      ctx.globalAlpha=1;
    } else if (b.type==='bomb'){
      ctx.fillStyle='#f1c40f'; ctx.beginPath(); ctx.arc(b.x,b.y,4,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#ff5555'; ctx.beginPath(); ctx.arc(b.x-2,b.y-4,2,0,Math.PI*2); ctx.fill();
    } else if (b.type==='enemyHoming'){
      ctx.fillStyle='#ff8c00'; ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#cc5500'; ctx.beginPath(); ctx.arc(b.x-2,b.y-2,1.5,0,Math.PI*2); ctx.fill();
    } else if (b.type==='torpedo'){
      ctx.fillStyle='#8be9fd'; ctx.fillRect(b.x, b.y-b.height/2, b.width, b.height);
      ctx.strokeStyle='#bd93f9'; ctx.lineWidth=2; ctx.strokeRect(b.x, b.y-b.height/2, b.width, b.height);
      ctx.strokeStyle='#ffffff'; ctx.lineWidth=1; ctx.beginPath();
      ctx.moveTo(b.x+4, b.y-6); ctx.lineTo(b.x+10, b.y-2); ctx.lineTo(b.x+16, b.y-6); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(b.x+6, b.y+6); ctx.lineTo(b.x+12, b.y+2); ctx.lineTo(b.x+18, b.y+6); ctx.stroke();
    } else {
      ctx.fillStyle='#ff5555'; ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
    }
  });

  // explosions
  explosions.forEach(ex=>{
    const pr = ex.timerMs / ex.maxTimerMs;
    const sz = ex.size*(1-pr);
    ctx.fillStyle = `rgba(255,85,85,${1-pr})`;
    ctx.beginPath(); ctx.arc(ex.x,ex.y,sz/2,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = `rgba(255,184,108,${1-pr})`;
    ctx.beginPath(); ctx.arc(ex.x,ex.y,sz/3,0,Math.PI*2); ctx.fill();
  });

  // powerups
  powerUps.forEach(p=>{
    ctx.save(); ctx.translate(p.x+8, p.y+8);
    const op = (Math.sin((p.timerMs||0)*0.1*0.06)+1)*0.5; ctx.globalAlpha=0.3+op*0.7;
    if (p.type==='bombs'){
      ctx.fillStyle='#f1c40f'; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#282a36'; ctx.font='12px monospace'; ctx.textAlign='center'; ctx.fillText('B',0,4);
    } else if (p.type==='shield'){
      ctx.strokeStyle='#8be9fd'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.stroke();
    } else if (p.type==='life'){
      ctx.fillStyle='#50fa7b'; ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(-9,12); ctx.lineTo(9,12); ctx.closePath(); ctx.fill();
    }
    ctx.restore();
  });

  ctx.restore();
}

function updateUI(){
  document.getElementById('score').textContent = score;
  document.getElementById('lives').textContent = lives;
  document.getElementById('bombs').textContent = bombs;
  document.getElementById('shield').textContent = Math.max(0, shield);
  document.getElementById('time').textContent = Math.floor(gameTime/1000);
  document.getElementById('distance').textContent = Math.floor(distanceTraveled/100);
  updateShipLevelUI();

  const pm = document.getElementById('powerMeter');
  const pctx = pm.getContext('2d');
  pctx.fillStyle='#282a36'; pctx.fillRect(0,0,pm.width,pm.height);
  pctx.strokeStyle='#6272a4'; pctx.lineWidth=2; pctx.strokeRect(2,2,pm.width-4,pm.height-4);
  const perc = Math.max(0,shield)/100, w=(pm.width-8)*perc;
  pctx.fillStyle = shield>60 ? '#50fa7b' : shield>30 ? '#ffb86c' : '#ff5555';
  pctx.fillRect(4,4,w,pm.height-8);
}

function updateShipLevelUI(){ document.getElementById('shipLevel').textContent = getShipLevel(); }

/* ================== Audio ================== */
function playSound(freq, dur, type='square', vol=0.1){
  if (!audioContext) return;
  const osc=audioContext.createOscillator(), g=audioContext.createGain();
  osc.connect(g); g.connect(audioContext.destination);
  osc.frequency.setValueAtTime(freq, audioContext.currentTime); osc.type=type;
  g.gain.setValueAtTime(vol, audioContext.currentTime);
  g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime+dur);
  osc.start(audioContext.currentTime); osc.stop(audioContext.currentTime+dur);
}
function playLaserSound(){ const now=Date.now(); if (now-lastLaserTime>50){ playSound(800,0.05,'square',0.02); lastLaserTime=now; } }
function playExplosionSound(){ playSound(300,0.2,'sawtooth',0.08); setTimeout(()=>playSound(150,0.1,'sawtooth',0.06),50); }
function playBombExplosionSound(){ playSound(100,0.3,'sawtooth',0.1); setTimeout(()=>playSound(80,0.2,'sawtooth',0.08),100); }
function playPowerUpSound(){ playSound(400,0.1,'sine',0.06); setTimeout(()=>playSound(600,0.1,'sine',0.06),50); }

/* ================== Shop (tiers to 3) ================== */
let lastShopTime = 0;
let credits = 0;
function showShop(){
  gameState='shop'; lastShopTime=gameTime;
  document.getElementById('shopCredits').textContent = `Credits: ${credits}`;
  updateShopButtons();
  const s=document.getElementById('shopScreen'); s.style.display='block'; setTimeout(()=>s.classList.add('show'),10);
}
function tierLabel(name, tier){ return `${name} TIER ${tier} of 3`; }
function updateShopButtons(){
  const c=document.getElementById('shopUpgrades'); c.innerHTML='';
  const add = (html)=>{ c.innerHTML += html; };

  if (upgrades.plasma < 3){
    const next=upgrades.plasma+1, cost=[0,100,200,350][next];
    add(`<div class="upgrade"><h3>${tierLabel('PLASMA BLASTER', next)} - ${cost} Credits</h3><p>Stronger, larger plasma with faster bolts. Current: ${upgrades.plasma}/3</p><button onclick="purchaseUpgrade('plasma', ${cost})" ${credits>=cost?'class="affordable"':''}>${upgrades.plasma===0?'PURCHASE':'UPGRADE'}</button></div>`);
  }
  if (upgrades.missiles < 3){
    const next=upgrades.missiles+1, cost=[0,100,200,350][next];
    add(`<div class="upgrade"><h3>${tierLabel('MISSILES', next)} - ${cost} Credits</h3><p>More rockets, angled nose launch. Current: ${upgrades.missiles}/3</p><button onclick="purchaseUpgrade('missiles', ${cost})" ${credits>=cost?'class="affordable"':''}>${upgrades.missiles===0?'PURCHASE':'UPGRADE'}</button></div>`);
  }
  if (upgrades.homing < 3){
    const next=upgrades.homing+1, cost=[0,200,400,600][next];
    add(`<div class="upgrade"><h3>${tierLabel('HOMING MISSILES', next)} - ${cost} Credits</h3><p>More homers, better coverage. Current: ${upgrades.homing}/3</p><button onclick="purchaseUpgrade('homing', ${cost})" ${credits>=cost?'class="affordable"':''}>${upgrades.homing===0?'PURCHASE':'UPGRADE'}</button></div>`);
  }
  if (upgrades.bombCapacity < 3){
    const next=upgrades.bombCapacity+1, cost=[0,150,250,350][next];
    const caps=[9,20,35,50];
    add(`<div class="upgrade"><h3>${tierLabel('BOMB CAPACITY', next)} - ${cost} Credits</h3><p>Max bombs â†’ ${caps[next]}. Current: ${upgrades.bombCapacity}/3</p><button onclick="purchaseUpgrade('bombCapacity', ${cost})" ${credits>=cost?'class="affordable"':''}>${upgrades.bombCapacity===0?'PURCHASE':'UPGRADE'}</button></div>`);
  }
  if (upgrades.torpedo < 3){
    const next=upgrades.torpedo+1, cost=[0,300,450,600][next];
    const cds=['Locked','1.4s','1.1s','0.9s'];
    add(`<div class="upgrade"><h3>${tierLabel('TORPEDO LAUNCHER', next)} - ${cost} Credits</h3><p>Unlock/boost T: damage up, cooldown ${cds[next]}.</p><button onclick="purchaseUpgrade('torpedo', ${cost})" ${credits>=cost?'class="affordable"':''}>${upgrades.torpedo===0?'PURCHASE':'UPGRADE'}</button></div>`);
  }
}
function closeShop(){
  const s=document.getElementById('shopScreen');
  s.classList.remove('show');
  setTimeout(()=>{
    s.style.display='none';
    gameState='playing';
    lastShopTime = gameTime + 5000;
    startMainLoop();
  },300);
}
function purchaseUpgrade(which, cost){
  if (credits < cost) return;
  if (which==='plasma' && upgrades.plasma>=3) return;
  if (which==='missiles' && upgrades.missiles>=3) return;
  if (which==='homing' && upgrades.homing>=3) return;
  if (which==='bombCapacity' && upgrades.bombCapacity>=3) return;
  if (which==='torpedo' && upgrades.torpedo>=3) return;

  credits -= cost;
  upgrades[which] += 1;
  updateShipLevelUI();
  document.getElementById('shopCredits').textContent=`Credits: ${credits}`;
  updateShopButtons();
}

/* ================== Scores (localStorage) ================== */
function loadHighScores(){
  const s=localStorage.getItem('defenderHighScores');
  try { highScores = s? JSON.parse(s):[]; if (!Array.isArray(highScores)) highScores = []; }
  catch { highScores = []; }
}
function saveHighScores(){
  try { localStorage.setItem('defenderHighScores', JSON.stringify(highScores)); }
  catch {}
}
function addHighScore(name,score){
  highScores.push({ name, score });
  highScores.sort((a,b)=> b.score - a.score);
  highScores = highScores.slice(0,10);
  saveHighScores();
}
function renderHighScores(listId){
  const ol = document.getElementById(listId);
  if (!ol) return;
  ol.innerHTML = '';
  highScores.forEach((hs, idx)=>{
    const li = document.createElement('li');
    li.textContent = `${idx+1}. ${hs.name || 'Anonymous'} â€” ${hs.score}`;
    ol.appendChild(li);
  });
}

/* ================== Loop ================== */
function gameLoop(now){
  if (gameState!=='playing') return;
  let delta = now - lastTime; if (delta>100) delta=100; lastTime=now;
  gameTime += delta;

  const timeBonus = Math.min(gameTime/600000, 0.2);
  const powerupBonus = Math.min((bombs-3)*0.05, 0.1);
  gameSpeed = 1.0 + timeBonus + powerupBonus;
  delta *= gameSpeed;

  const dt = delta / 16.67;

  updatePlayer(dt, delta);
  updateBullets(dt, delta);
  updateEnemies(dt, delta);
  updatePowerUps(dt, delta);
  updateExplosions(delta);
  checkCollisions();
  spawnEnemy(delta);

  if (gameTime - lastShopTime > 30000) showShop();

  draw();
  updateUI();
  requestAnimationFrame(gameLoop);
}

/* ================== Init ================== */
function initAudio(){ /* deferred to interaction */ }
loadHighScores(); renderHighScores('highScoreList');
initTerrain(); initStars(); initAudio();
</script>
</body>
</html>
