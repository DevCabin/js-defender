<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defender - Space Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #282a36;
            color: #f8f8f2;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #gameCanvas {
            border: 2px solid #44475a;
            background: linear-gradient(to bottom, #282a36 0%, #21222c 50%, #191a21 100%);
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
            background: rgba(40, 42, 54, 0.9);
            padding: 20px;
            border: 2px solid #6272a4;
            border-radius: 8px;
        }
        input {
            background: #44475a;
            border: 1px solid #6272a4;
            color: #f8f8f2;
            padding: 5px;
            margin: 10px;
        }
        button {
            background: #44475a;
            border: 1px solid #6272a4;
            color: #f8f8f2;
            padding: 10px 20px;
            cursor: pointer;
        }
        button:hover {
            background: #6272a4;
        }
        button.affordable {
            background: #50fa7b;
            color: #282a36;
        }
        button.affordable:hover {
            background: #7bfaad;
        }
        #shopScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
            background: rgba(40, 42, 54, 0.95);
            padding: 20px;
            border: 2px solid #6272a4;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #shopScreen.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="600"></canvas>
    
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Bombs: <span id="bombs">3</span></div>
        <div>Shield: <span id="shield">100</span>%</div>
        <div>Time: <span id="time">0</span>s</div>
        <div style="margin-top: 10px;">
            <div style="color: #50fa7b; font-size: 12px;">POWER</div>
            <canvas id="powerMeter" width="100" height="20" style="border: 1px solid #6272a4; background: #282a36;"></canvas>
        </div>
    </div>

    <div id="startScreen">
        <h1>DEFENDER</h1>
        <p>Protect the planet from alien invaders!</p>
        <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
        <br>
        <button onclick="startGame()">START GAME</button>
        <br><br>
        <p>Controls:</p>
        <p>Arrow Keys: Move | Spacebar: Laser | B: Bomb</p>
    </div>

    <div id="gameOverScreen" style="display: none;">
        <h1>GAME OVER</h1>
        <p id="finalScore"></p>
        <p id="playerNameDisplay"></p>
        <button onclick="resetGame()">PLAY AGAIN</button>
    </div>

    <div id="shopScreen" style="display: none;">
        <h1>UPGRADE SHOP</h1>
        <p id="shopCredits">Credits: 0</p>
        <div id="shopUpgrades">
            <div class="upgrade" id="plasmaBlaster">
                <h3>PLASMA BLASTER - 100 Credits</h3>
                <p>Larger purple projectiles, reduced fire rate, increased damage</p>
                <button onclick="purchaseUpgrade('plasmaBlaster')">PURCHASE</button>
            </div>
            <div class="upgrade" id="missiles">
                <h3>MISSILES - 100 Credits</h3>
                <p>White rockets below blaster, slower but high damage</p>
                <button onclick="purchaseUpgrade('missiles')">PURCHASE</button>
            </div>
            <div class="upgrade" id="homingMissiles">
                <h3>HOMING MISSILES - 200 Credits</h3>
                <p>Red projectiles that auto-target strongest enemy</p>
                <button onclick="purchaseUpgrade('homingMissiles')">PURCHASE</button>
            </div>
        </div>
        <button onclick="closeShop()">CONTINUE GAME</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'start';
        let playerName = '';
        let gameTime = 0;
        let lastTime = 0;
        let score = 0;
        let lives = 3;
        let bombs = 3;
        let shield = 100;
        let lastBossTime = 0;
        let cameraX = 0;
        let highScores = [];
        let gameSpeed = 1.0; // Start at normal speed, can increase

        // Upgrade system
        let credits = 0;
        let lastShopTime = 0;
        let upgrades = {
            plasmaBlaster: false,
            missiles: 0, // 0 = none, 1 = tier 1, 2 = tier 2
            homingMissiles: 0, // 0 = none, 1 = tier 1, 2 = tier 2
            bombCapacity: false // false = 9 max, true = 50 max
        };

        // Audio system
        let audioContext = null;
        let lastLaserTime = 0;
        
        // Input handling
        let keys = {};
        let shootTimer = 0;
        let homingMissileTimer = 0;
        const shootDelay = 8;
        const homingMissileDelay = 24; // Slower firing rate for homing missiles (3x slower)
        
        // Game objects
        let player = {
            x: 100,
            y: 300,
            width: 20,
            height: 16,
            vx: 0,
            vy: 0,
            maxSpeed: 3 // Slower for beginners
        };
        
        let bullets = [];
        let enemies = [];
        let explosions = [];
        let powerUps = [];
        let stars = [];
        let terrain = [];
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ') e.preventDefault();
            if (e.key && e.key.toLowerCase() === 'b' && gameState === 'playing') {
                dropBomb();
            }
            if (e.key === 'Enter') {
                if (gameState === 'start') {
                    startGame();
                } else if (gameState === 'shop') {
                    closeShop();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // Infinite world - no fixed width limit
        let terrainGeneratedUpTo = 0;

        function initTerrain() {
            terrain = [];
            // Generate initial terrain for 3 screen widths
            generateTerrainSegment(0, canvas.width * 3);
        }

        function generateTerrainSegment(startX, endX) {
            for (let x = startX; x < endX; x += 10) {
                let height = 450 + Math.sin(x * 0.02) * 20 + Math.sin(x * 0.005) * 40;
                if (Math.random() < 0.1) {
                    let craterWidth = 40 + Math.random() * 60;
                    let craterDepth = 20 + Math.random() * 30;
                    for (let i = 0; i < craterWidth; i += 10) {
                        if (x + i < endX) {
                            let craterHeight = height + Math.sin((i / craterWidth) * Math.PI) * craterDepth;
                            terrain.push({ x: x + i, y: craterHeight });
                        }
                    }
                    x += craterWidth;
                } else {
                    terrain.push({ x: x, y: height });
                }
            }
            terrainGeneratedUpTo = endX;
        }


        
        function initStars() {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.8,
                    brightness: Math.random()
                });
            }
        }
        
        function startGame() {
            playerName = document.getElementById('playerName').value || 'Anonymous';
            document.getElementById('startScreen').style.display = 'none';
            gameState = 'playing';
            resetGameVars();
            initTerrain();
            initStars();
            gameLoop(0);
        }
        
        function resetGameVars() {
            gameTime = 0;
            score = 0;
            lives = 3;
            bombs = 3;
            shield = 100;
            lastBossTime = 0;
            shootTimer = 0;
            player.x = 100;
            player.y = 300;
            player.vx = 0;
            player.vy = 0;
            bullets = [];
            enemies = [];
            explosions = [];
            powerUps = [];
        }
        
        function resetGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            gameState = 'start';
        }
        
        function shoot() {
            // Primary weapon - Plasma Blaster if owned, otherwise regular laser
            if (upgrades.plasmaBlaster) {
                bullets.push({
                    x: player.x + player.width,
                    y: player.y + player.height / 2,
                    vx: 6, // Slower speed
                    vy: 0,
                    type: 'plasma',
                    width: 20, // Larger
                    height: 6,
                    damage: 2 // Higher damage
                });
            } else {
                bullets.push({
                    x: player.x + player.width,
                    y: player.y + player.height / 2,
                    vx: 8,
                    vy: 0,
                    type: 'laser',
                    width: 12,
                    height: 3,
                    damage: 1
                });
            }

            // Secondary weapons - Missiles
            if (upgrades.missiles >= 1) {
                // Tier 1 missile (below)
                bullets.push({
                    x: player.x + player.width,
                    y: player.y + player.height / 2 + 8,
                    vx: 4,
                    vy: 0,
                    type: 'missile',
                    width: 8,
                    height: 4,
                    damage: 3,
                    tier: 1
                });
            }

            if (upgrades.missiles >= 2) {
                // Tier 2 missile (above)
                bullets.push({
                    x: player.x + player.width,
                    y: player.y + player.height / 2 - 8,
                    vx: 4,
                    vy: 0,
                    type: 'missile',
                    width: 8,
                    height: 4,
                    damage: 3,
                    tier: 2
                });
            }

            playLaserSound();
        }

        function shootHomingMissiles() {
            // Homing Missiles - fired at slower rate
            if (upgrades.homingMissiles >= 1) {
                // Tier 1: Target strongest enemy
                let targetEnemy = null;
                let maxHealth = 0;
                enemies.forEach(enemy => {
                    if (enemy.health > maxHealth) {
                        maxHealth = enemy.health;
                        targetEnemy = enemy;
                    }
                });

                if (targetEnemy) {
                    console.log('Firing homing missile at enemy with health:', maxHealth);
                    let dx = targetEnemy.x + targetEnemy.width/2 - (player.x + player.width);
                    let dy = targetEnemy.y + targetEnemy.height/2 - (player.y + player.height/2);
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    let speed = 3;

                    bullets.push({
                        x: player.x + player.width,
                        y: player.y + player.height / 2 - 8,
                        vx: (dx / distance) * speed,
                        vy: (dy / distance) * speed,
                        type: 'homing',
                        width: 6,
                        height: 6,
                        damage: 2,
                        target: targetEnemy,
                        tier: 1
                    });
                }
            }

            if (upgrades.homingMissiles >= 2) {
                // Tier 2: Target nearest enemy with full health (not yet fired upon)
                let targetEnemy = null;
                let minDistance = Infinity;

                enemies.forEach(enemy => {
                    if (enemy.health === enemy.maxHealth || enemy.health > 5) { // Target healthy enemies
                        let dx = enemy.x + enemy.width/2 - (player.x + player.width);
                        let dy = enemy.y + enemy.height/2 - (player.y + player.height/2);
                        let distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < minDistance) {
                            minDistance = distance;
                            targetEnemy = enemy;
                        }
                    }
                });

                if (targetEnemy) {
                    let dx = targetEnemy.x + targetEnemy.width/2 - (player.x + player.width);
                    let dy = targetEnemy.y + targetEnemy.height/2 - (player.y + player.height/2);
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    let speed = 3;

                    bullets.push({
                        x: player.x + player.width,
                        y: player.y + player.height / 2 + 8, // Below tier 1
                        vx: (dx / distance) * speed,
                        vy: (dy / distance) * speed,
                        type: 'homing',
                        width: 6,
                        height: 6,
                        damage: 2,
                        target: targetEnemy,
                        tier: 2
                    });
                }
            }
        }
        
        function dropBomb() {
            if (bombs > 0) {
                bombs--;
                bullets.push({
                    x: player.x,
                    y: player.y + player.height,
                    vx: 0,
                    vy: 3,
                    type: 'bomb',
                    width: 8,
                    height: 8
                });
            }
        }
        
        function getTerrainHeight(x) {
            for (let i = 0; i < terrain.length - 1; i++) {
                if (x >= terrain[i].x && x <= terrain[i + 1].x) {
                    return terrain[i].y;
                }
            }
            return 450;
        }
        
        function spawnEnemy() {
            let enemyTypes = ['fighter', 'bomber', 'dinosaur'];
            // Start with extremely low spawn rate, increase very gradually
            let baseSpawnChance = Math.min(0.0005 + gameTime * 0.00001, 0.02); // Even lower starting rate
            // Add progressive difficulty: increase spawn rate over time
            let difficultyMultiplier = 1 + Math.floor(gameTime / 120000) * 0.15; // Much slower increase
            let spawnChance = Math.min(baseSpawnChance * difficultyMultiplier, 0.04); // Much lower max rate

            // Limit dinosaurs on screen - very restrictive at start
            let currentDinosaurs = enemies.filter(e => e.type === 'dinosaur').length;
            let maxDinosaurs = gameTime < 15000 ? 0 : // First 15 seconds: NO dinosaurs
                              gameTime < 45000 ? 1 : // Next 30 seconds: max 1 dinosaur
                              gameTime < 90000 ? 2 : // Next 45 seconds: max 2 dinosaurs
                              3; // After that: max 3 dinosaurs

            if (Math.random() < spawnChance) {
                let type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

                // Don't spawn dinosaur if we've reached the limit
                if (type === 'dinosaur' && currentDinosaurs >= maxDinosaurs) {
                    type = enemyTypes[Math.floor(Math.random() * 2)]; // Pick fighter or bomber instead
                }

                let spawnX = cameraX + canvas.width + 50;
                let enemyHealth = type === 'dinosaur' ? 3 + Math.floor(gameTime / 45000) : 1 + Math.floor(gameTime / 60000);
                let enemy = {
                    type: type,
                    x: spawnX,
                    y: type === 'dinosaur' ? getTerrainHeight(spawnX) - 35 : Math.random() * (canvas.height - 200),
                    width: type === 'dinosaur' ? 45 : type === 'boss' ? 80 : 25,
                    height: type === 'dinosaur' ? 35 : type === 'boss' ? 60 : 20,
                    vx: -1.5 - Math.random() * 1 - Math.floor(gameTime / 60000) * 0.15, // Much slower speed increase over time
                    vy: 0,
                    health: enemyHealth,
                    maxHealth: enemyHealth, // Store initial health for tier 2 homing missiles
                    shootTimer: 0,
                    walkTimer: type === 'dinosaur' ? Math.random() * 100 : 0 // For walking animation
                };
                enemies.push(enemy);
            }

            // Boss spawn interval decreases over time
            let bossInterval = Math.max(20000 - Math.floor(gameTime / 60000) * 3000, 10000);
            if (gameTime - lastBossTime > bossInterval) {
                let spawnX = cameraX + canvas.width + 100;
                let bossHealth = 10 + Math.floor(gameTime / 45000) * 5;
                enemies.push({
                    type: 'boss',
                    x: spawnX,
                    y: canvas.height / 2 - 40,
                    width: 80,
                    height: 60,
                    vx: -1 - Math.floor(gameTime / 120000) * 0.15, // Much slower boss speed increase
                    vy: 0,
                    health: bossHealth,
                    maxHealth: bossHealth, // Store initial health for tier 2 homing missiles
                    shootTimer: 0,
                    moveTimer: 0
                });
                lastBossTime = gameTime;
            }
        }
        
        function updatePlayer() {
            if (keys['ArrowLeft']) player.vx = Math.max(player.vx - 0.6, -player.maxSpeed);
            if (keys['ArrowRight']) player.vx = Math.min(player.vx + 0.6, player.maxSpeed);
            if (keys['ArrowUp']) player.vy = Math.max(player.vy - 0.6, -player.maxSpeed);
            if (keys['ArrowDown']) player.vy = Math.min(player.vy + 0.6, player.maxSpeed);

            if (keys[' '] && gameState === 'playing') {
                shootTimer++;
                homingMissileTimer++;

                // Regular weapons (laser/plasma/missiles) - normal fire rate
                let currentShootDelay = upgrades.plasmaBlaster ? shootDelay * 1.5 : shootDelay;
                if (shootTimer >= currentShootDelay) {
                    shoot();
                    shootTimer = 0;
                }

                // Homing missiles - slower fire rate
                if (homingMissileTimer >= homingMissileDelay) {
                    shootHomingMissiles();
                    homingMissileTimer = 0;
                }
            } else {
                shootTimer = 0;
                homingMissileTimer = 0;
            }

            player.vx *= 0.92;
            player.vy *= 0.92;
            player.x += player.vx;
            player.y += player.vy;

            // Update camera to follow player - infinite world, no bounds
            cameraX = player.x - canvas.width / 2;

            // Generate more terrain if needed (keep 2 screens ahead)
            if (cameraX + canvas.width * 2 > terrainGeneratedUpTo) {
                generateTerrainSegment(terrainGeneratedUpTo, terrainGeneratedUpTo + canvas.width);
            }

            // Keep player within reasonable bounds vertically
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let bullet = bullets[i];

                // Homing missile targeting logic
                if (bullet.type === 'homing' && bullet.target && enemies.includes(bullet.target)) {
                    let target = bullet.target;
                    let dx = target.x + target.width/2 - bullet.x;
                    let dy = target.y + target.height/2 - bullet.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        // Adjust velocity towards target (smooth homing)
                        let homingSpeed = 3;
                        let homingStrength = 0.1; // How aggressively it turns

                        let targetVx = (dx / distance) * homingSpeed;
                        let targetVy = (dy / distance) * homingSpeed;

                        bullet.vx += (targetVx - bullet.vx) * homingStrength;
                        bullet.vy += (targetVy - bullet.vy) * homingStrength;

                        // Normalize speed to maintain consistent velocity
                        let currentSpeed = Math.sqrt(bullet.vx * bullet.vx + bullet.vy * bullet.vy);
                        if (currentSpeed > 0) {
                            bullet.vx = (bullet.vx / currentSpeed) * homingSpeed;
                            bullet.vy = (bullet.vy / currentSpeed) * homingSpeed;
                        }
                    }
                }

                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                // Remove bullets that are far off screen (accounting for world coordinates)
                if (bullet.x > cameraX + canvas.width + 100 || bullet.x < cameraX - 100 || bullet.y > canvas.height + 50) {
                    bullets.splice(i, 1);
                    continue;
                }

                if (bullet.type === 'bomb' && bullet.y > getTerrainHeight(bullet.x) - 10) {
                    createExplosion(bullet.x, bullet.y, 60);
                    playBombExplosionSound();
                    enemies.forEach(enemy => {
                        let dist = Math.sqrt((enemy.x + enemy.width/2 - bullet.x) ** 2 + (enemy.y + enemy.height/2 - bullet.y) ** 2);
                        if (dist < 80) {
                            enemy.health -= 3;
                        }
                    });
                    bullets.splice(i, 1);
                }
            }
        }
        
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                enemy.x += enemy.vx;
                enemy.y += enemy.vy;

                if (enemy.type === 'boss') {
                    enemy.moveTimer++;
                    enemy.vy = Math.sin(enemy.moveTimer * 0.05) * 2;
                }

                if (enemy.type === 'dinosaur') {
                    // Ground enemy behavior - follow terrain
                    enemy.walkTimer++;
                    let terrainHeight = getTerrainHeight(enemy.x + enemy.width/2);
                    let targetY = terrainHeight - enemy.height;

                    // Smoothly move towards terrain height
                    let dy = targetY - enemy.y;
                    enemy.vy = dy * 0.1; // Smooth terrain following

                    // Add slight bobbing for walking animation
                    enemy.y += Math.sin(enemy.walkTimer * 0.3) * 0.5;

                    // Randomly change direction occasionally
                    if (Math.random() < 0.005) {
                        enemy.vx = -enemy.vx;
                    }

                    // Don't let dinosaurs go too high or too low
                    if (enemy.y < targetY - 10) enemy.y = targetY - 10;
                    if (enemy.y > targetY + 10) enemy.y = targetY + 10;
                }

                enemy.shootTimer++;
                // Enemies shoot dramatically less frequently for beginner-friendly experience
                let shootDelay = gameTime < 30000 ? 300 + Math.random() * 200 : // First 30 seconds: very slow shooting (5-8.3 seconds)
                                gameTime < 60000 ? 240 + Math.random() * 120 :   // Next 30 seconds: slow shooting (4-6 seconds)
                                gameTime < 120000 ? 180 + Math.random() * 90 :   // Next 60 seconds: moderate shooting (3-4.5 seconds)
                                120 + Math.random() * 60;                        // After that: normal shooting (2-3 seconds)

                if (enemy.shootTimer > shootDelay) {
                    if (enemy.type !== 'dinosaur' || enemy.y > canvas.height - 100) {
                        bullets.push({
                            x: enemy.x,
                            y: enemy.y + enemy.height / 2,
                            vx: -2, // Slower enemy bullets
                            vy: 0,
                            type: 'enemy',
                            width: 6,
                            height: 6
                        });
                    }
                    enemy.shootTimer = 0;
                }

                if (enemy.x < -100 || enemy.health <= 0) {
                    if (enemy.health <= 0) {
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.type === 'boss' ? 80 : 40);
                        playExplosionSound();

                        // Award credits based on enemy type
                        let enemyCredits = enemy.type === 'boss' ? 50 :
                                         enemy.type === 'dinosaur' ? 10 :
                                         enemy.type === 'bomber' ? 5 : 1;
                        credits += enemyCredits;

                        score += enemy.type === 'boss' ? 500 : enemy.type === 'dinosaur' ? 150 : 100;

                        if (Math.random() < (enemy.type === 'boss' ? 1 : 0.3)) {
                            spawnPowerUp(enemy.x, enemy.y, enemy.type === 'boss');
                        }
                    }
                    enemies.splice(i, 1);
                }
            }
        }
        
        function spawnPowerUp(x, y, isBoss) {
            let types = ['bombs', 'shield'];
            if (isBoss) types.push('life');

            let type = types[Math.floor(Math.random() * types.length)];

            powerUps.push({
                x: x,
                y: y,
                vx: 0, // Initialize horizontal velocity
                vy: 0, // Start with no vertical velocity (hovering)
                type: type,
                timer: 0,
                hoverTimer: 0,
                hoverDuration: 480 + Math.random() * 240, // 8-12 seconds at 60fps (480-720 frames) - much longer hover time
                width: 16,
                height: 16
            });
        }
        
        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                let powerUp = powerUps[i];
                powerUp.hoverTimer++;

                // After hover duration, start falling
                if (powerUp.hoverTimer >= powerUp.hoverDuration) {
                    powerUp.vy = 2; // Start falling
                }

                // Magnetic attraction to player
                let dx = (player.x + player.width/2) - (powerUp.x + powerUp.width/2);
                let dy = (player.y + player.height/2) - (powerUp.y + powerUp.height/2);
                let distance = Math.sqrt(dx * dx + dy * dy);

                // If within magnetic range (150 pixels), attract towards player
                if (distance < 150) {
                    let attractionStrength = Math.max(0.3, 2 - distance / 75); // Weaker attraction, longer range
                    let angle = Math.atan2(dy, dx);

                    // Apply magnetic force more gently
                    powerUp.vx += Math.cos(angle) * attractionStrength * 0.1;
                    powerUp.vy += Math.sin(angle) * attractionStrength * 0.1;

                    // Stronger damping to prevent overshooting
                    powerUp.vx *= 0.9;
                    powerUp.vy *= 0.9;
                } else {
                    // Reset velocity when out of range
                    powerUp.vx *= 0.95;
                    powerUp.vy *= 0.95;
                }

                powerUp.x += powerUp.vx;
                powerUp.y += powerUp.vy;
                powerUp.timer++;

                if (powerUp.y > canvas.height || powerUp.timer > 600) { // Extended lifetime for falling
                    powerUps.splice(i, 1);
                    continue;
                }

                if (checkCollision(player, powerUp)) {
                    switch (powerUp.type) {
                        case 'bombs':
                            const maxBombs = upgrades.bombCapacity ? 50 : 9;
                            bombs = Math.min(bombs + 3, maxBombs);
                            break;
                        case 'shield':
                            shield = Math.min(shield + 25, 100);
                            break;
                        case 'life':
                            lives++;
                            break;
                    }
                    score += 50;
                    playPowerUpSound();
                    powerUps.splice(i, 1);
                }
            }
        }
        
        function checkCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }
        
        function checkCollisions() {
            // Bullet vs enemy collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                let bullet = bullets[i];
                if (bullet.type === 'enemy') continue;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    let enemy = enemies[j];
                    if (checkCollision(bullet, enemy)) {
                        enemy.health -= bullet.damage || 1; // Use bullet damage or default to 1
                        if (bullet.type === 'laser' || bullet.type === 'plasma') {
                            bullets.splice(i, 1);
                        }
                        createExplosion(bullet.x, bullet.y, 25);
                        break;
                    }
                }
            }
            
            // Enemy bullet vs player
            for (let i = bullets.length - 1; i >= 0; i--) {
                let bullet = bullets[i];
                if (bullet.type !== 'enemy') continue;
                
                if (checkCollision(bullet, player)) {
                    shield -= 10;
                    bullets.splice(i, 1);
                    createExplosion(player.x + player.width/2, player.y + player.height/2, 30);
                }
            }
            
            enemies.forEach(enemy => {
                if (checkCollision(enemy, player)) {
                    shield -= 20;
                    createExplosion(player.x + player.width/2, player.y + player.height/2, 40);
                    enemy.health = 0;
                }
            });
            
            if (shield <= 0) {
                lives--;
                shield = 100;
                if (lives <= 0) {
                    gameOver();
                }
            }
        }
        
        function createExplosion(x, y, size) {
            explosions.push({
                x: x,
                y: y,
                size: size,
                timer: 0,
                maxTimer: 20
            });
        }
        
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                let explosion = explosions[i];
                explosion.timer++;
                if (explosion.timer >= explosion.maxTimer) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        function gameOver() {
            gameState = 'gameOver';
            let finalScore = score + Math.floor(gameTime / 1000) * 10;

            // Check if it's a high score
            if (isHighScore(finalScore)) {
                addHighScore(playerName, finalScore);
                document.getElementById('finalScore').textContent = `NEW HIGH SCORE: ${finalScore}`;
            } else {
                document.getElementById('finalScore').textContent = `Final Score: ${finalScore}`;
            }

            document.getElementById('playerNameDisplay').textContent = `Player: ${playerName}`;
            document.getElementById('gameOverScreen').style.display = 'block';
        }
        
        function draw() {
            // Clear with solid background
            ctx.fillStyle = '#282a36';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-cameraX, 0);

            // Draw stars
            ctx.fillStyle = '#8be9fd';
            stars.forEach(star => {
                ctx.globalAlpha = star.brightness * 0.7;
                ctx.fillRect(star.x + cameraX, star.y, 1, 1);
            });
            ctx.globalAlpha = 1;

            // Draw terrain
            ctx.strokeStyle = '#ffb86c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            terrain.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();

            ctx.fillStyle = '#bd93f9';
            ctx.beginPath();
            terrain.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(canvas.width + cameraX, canvas.height);
            ctx.lineTo(cameraX, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // Draw player as triangle ship
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            ctx.fillStyle = '#50fa7b';
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, -8);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, 8);
            ctx.closePath();
            ctx.fill();
            
            // Engine glow
            ctx.fillStyle = '#ff5555';
            ctx.beginPath();
            ctx.moveTo(-5, -3);
            ctx.lineTo(-15, 0);
            ctx.lineTo(-5, 3);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // Draw enemies with simple Atari-style pixel monsters
            enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);

                if (enemy.type === 'dinosaur') {
                    // Simple pixel dinosaur - blocky and retro
                    ctx.fillStyle = '#50fa7b';

                    // Body - simple rectangle
                    ctx.fillRect(8, 15, 16, 12);

                    // Head - simple square
                    ctx.fillRect(20, 10, 8, 8);

                    // Legs - simple lines
                    ctx.fillRect(10, 27, 2, 8);
                    ctx.fillRect(18, 27, 2, 8);

                    // Eyes - simple dots
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(22, 12, 1, 1);
                    ctx.fillRect(25, 12, 1, 1);

                    // Spikes - simple triangles
                    ctx.fillStyle = '#50fa7b';
                    ctx.fillRect(8, 12, 2, 3);
                    ctx.fillRect(12, 10, 2, 5);
                    ctx.fillRect(16, 8, 2, 7);

                } else if (enemy.type === 'fighter') {
                    // Simple pixel fighter - like a flying saucer
                    ctx.fillStyle = '#ff5555';

                    // Main body - oval shape with pixels
                    ctx.fillRect(6, 8, 12, 8);

                    // Wings - simple rectangles
                    ctx.fillRect(2, 10, 4, 4);
                    ctx.fillRect(18, 10, 4, 4);

                    // Cockpit - small rectangle
                    ctx.fillStyle = '#ffb86c';
                    ctx.fillRect(10, 6, 4, 4);

                } else if (enemy.type === 'bomber') {
                    // Simple pixel bomber - boxy plane
                    ctx.fillStyle = '#ffb86c';

                    // Fuselage
                    ctx.fillRect(8, 12, 8, 6);

                    // Wings
                    ctx.fillRect(4, 14, 4, 2);
                    ctx.fillRect(16, 14, 4, 2);

                    // Tail
                    ctx.fillRect(10, 8, 4, 4);

                } else if (enemy.type === 'boss') {
                    // Simple pixel boss - large blocky monster
                    ctx.fillStyle = '#ff5555';

                    // Main body
                    ctx.fillRect(10, 15, 20, 15);

                    // Eyes
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(14, 18, 2, 2);
                    ctx.fillRect(24, 18, 2, 2);

                    // Mouth
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(16, 25, 8, 2);

                    // Antennas
                    ctx.fillStyle = '#ff5555';
                    ctx.fillRect(12, 10, 1, 5);
                    ctx.fillRect(27, 10, 1, 5);
                }

                ctx.restore();
            });
            
            // Draw bullets
            bullets.forEach(bullet => {
                if (bullet.type === 'laser') {
                    ctx.strokeStyle = '#8be9fd';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(bullet.x, bullet.y);
                    ctx.lineTo(bullet.x + 12, bullet.y);
                    ctx.stroke();

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(bullet.x, bullet.y);
                    ctx.lineTo(bullet.x + 12, bullet.y);
                    ctx.stroke();
                } else if (bullet.type === 'plasma') {
                    // Larger purple plasma bolt
                    ctx.fillStyle = '#bd93f9';
                    ctx.fillRect(bullet.x, bullet.y - 3, bullet.width, bullet.height);

                    ctx.strokeStyle = '#ff79c6';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(bullet.x, bullet.y - 3, bullet.width, bullet.height);
                } else if (bullet.type === 'missile') {
                    // White rocket
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(bullet.x, bullet.y - 2, bullet.width, bullet.height);

                    // Rocket trail
                    ctx.fillStyle = '#ff5555';
                    ctx.fillRect(bullet.x - 4, bullet.y - 1, 4, 2);
                } else if (bullet.type === 'homing') {
                    // Red homing missile with white tail
                    ctx.fillStyle = '#ff5555';
                    ctx.fillRect(bullet.x, bullet.y - bullet.height/2, bullet.width, bullet.height);

                    // White missile tail
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(bullet.x - bullet.width/2, bullet.y - bullet.height/4, bullet.width/2, bullet.height/2);

                    // Targeting indicator (subtle)
                    ctx.strokeStyle = '#ff5555';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(bullet.x + bullet.width/2, bullet.y, bullet.width * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else if (bullet.type === 'bomb') {
                    ctx.fillStyle = '#f1c40f';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#ff5555';
                    ctx.beginPath();
                    ctx.arc(bullet.x - 2, bullet.y - 4, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#ff5555';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw explosions
            explosions.forEach(explosion => {
                let progress = explosion.timer / explosion.maxTimer;
                let size = explosion.size * (1 - progress);
                
                ctx.fillStyle = `rgba(255, 85, 85, ${1 - progress})`;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, size / 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(255, 184, 108, ${1 - progress})`;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, size / 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw power-ups
            powerUps.forEach(powerUp => {
                ctx.save();
                ctx.translate(powerUp.x + 8, powerUp.y + 8);

                // Smooth opacity pulsing instead of on/off blinking
                let opacity = (Math.sin(powerUp.timer * 0.1) + 1) * 0.5; // 0 to 1 range
                ctx.globalAlpha = 0.3 + opacity * 0.7; // 0.3 to 1.0 opacity

                switch (powerUp.type) {
                    case 'bombs':
                        ctx.fillStyle = '#f1c40f';
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#282a36';
                        ctx.font = '12px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('B', 0, 4);
                        break;
                    case 'shield':
                        ctx.strokeStyle = '#8be9fd';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'life':
                        // Larger free life powerup
                        ctx.fillStyle = '#50fa7b';
                        ctx.beginPath();
                        ctx.moveTo(0, -12);
                        ctx.lineTo(-9, 12);
                        ctx.lineTo(9, 12);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                ctx.restore();
            });

            ctx.restore(); // Restore camera translation
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('bombs').textContent = bombs;
            document.getElementById('shield').textContent = Math.max(0, shield);
            document.getElementById('time').textContent = Math.floor(gameTime / 1000);

            // Draw power meter
            const powerMeterCanvas = document.getElementById('powerMeter');
            const pmCtx = powerMeterCanvas.getContext('2d');

            // Clear power meter
            pmCtx.fillStyle = '#282a36';
            pmCtx.fillRect(0, 0, powerMeterCanvas.width, powerMeterCanvas.height);

            // Draw power meter background
            pmCtx.strokeStyle = '#6272a4';
            pmCtx.lineWidth = 2;
            pmCtx.strokeRect(2, 2, powerMeterCanvas.width - 4, powerMeterCanvas.height - 4);

            // Draw power level
            const powerPercent = Math.max(0, shield) / 100;
            const barWidth = (powerMeterCanvas.width - 8) * powerPercent;

            // Color based on health level
            if (shield > 60) {
                pmCtx.fillStyle = '#50fa7b'; // Green for good health
            } else if (shield > 30) {
                pmCtx.fillStyle = '#ffb86c'; // Yellow for medium health
            } else {
                pmCtx.fillStyle = '#ff5555'; // Red for low health
            }

            pmCtx.fillRect(4, 4, barWidth, powerMeterCanvas.height - 8);
        }
        
        function gameLoop(currentTime) {
            if (gameState !== 'playing') return;

            let deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            gameTime += deltaTime;

            // Gradually increase game speed over time and with powerups (much slower progression)
            let baseSpeed = 1.0;
            let timeBonus = Math.min(gameTime / 600000, 0.2); // Max 20% speed increase over 10 minutes (much slower)
            let powerupBonus = Math.min((bombs - 3) * 0.05, 0.1); // Speed up with extra bombs (max 10%, much less aggressive)
            gameSpeed = baseSpeed + timeBonus + powerupBonus;

            // Apply speed multiplier to deltaTime
            let adjustedDeltaTime = deltaTime * gameSpeed;

            updatePlayer();
            updateBullets();
            updateEnemies();
            updatePowerUps();
            updateExplosions();
            checkCollisions();
            spawnEnemy();

                    // Check for shop every 30 seconds
            if (gameTime - lastShopTime > 30000) {
                showShop();
            }

            draw();
            updateUI();

            requestAnimationFrame(gameLoop);
        }
        
        // Load high scores from localStorage
        function loadHighScores() {
            const saved = localStorage.getItem('defenderHighScores');
            if (saved) {
                highScores = JSON.parse(saved);
            } else {
                highScores = [];
            }
        }

        // Save high scores to localStorage
        function saveHighScores() {
            localStorage.setItem('defenderHighScores', JSON.stringify(highScores));
        }

        // Add score to high scores list
        function addHighScore(name, score) {
            highScores.push({ name: name, score: score });
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 10); // Keep only top 10
            saveHighScores();
        }

        // Check if score is a high score
        function isHighScore(score) {
            return highScores.length < 10 || score > highScores[highScores.length - 1].score;
        }

        // Audio functions
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Web Audio API not supported');
            }
        }

        function playSound(frequency, duration, type = 'square', volume = 0.1) {
            if (!audioContext) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type;

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playLaserSound() {
            // Very quiet laser sound - only play if enough time has passed
            const now = Date.now();
            if (now - lastLaserTime > 50) { // Limit to prevent spam
                playSound(800, 0.05, 'square', 0.02);
                lastLaserTime = now;
            }
        }

        function playExplosionSound() {
            // Enemy explosion - descending tone
            playSound(300, 0.2, 'sawtooth', 0.08);
            setTimeout(() => playSound(150, 0.1, 'sawtooth', 0.06), 50);
        }

        function playBombExplosionSound() {
            // Bomb explosion - low frequency rumble
            playSound(100, 0.3, 'sawtooth', 0.1);
            setTimeout(() => playSound(80, 0.2, 'sawtooth', 0.08), 100);
        }

        function playPowerUpSound() {
            // Positive ascending tone for power-ups
            playSound(400, 0.1, 'sine', 0.06);
            setTimeout(() => playSound(600, 0.1, 'sine', 0.06), 50);
        }

        // Shop functions
        function showShop() {
            console.log('Shop triggered! Credits:', credits, 'Upgrades:', upgrades);
            gameState = 'shop';
            lastShopTime = gameTime;
            document.getElementById('shopCredits').textContent = `Credits: ${credits}`;

            updateShopButtons();

            const shopScreen = document.getElementById('shopScreen');
            shopScreen.style.display = 'block';
            // Use setTimeout to ensure display:block is applied before adding the class
            setTimeout(() => {
                shopScreen.classList.add('show');
            }, 10);
        }

        function updateShopButtons() {
            const shopUpgrades = document.getElementById('shopUpgrades');
            shopUpgrades.innerHTML = ''; // Clear all existing items

            // Plasma Blaster - only show if not purchased
            if (!upgrades.plasmaBlaster) {
                const plasmaDiv = document.createElement('div');
                plasmaDiv.className = 'upgrade';
                plasmaDiv.id = 'plasmaBlaster';
                plasmaDiv.innerHTML = `
                    <h3>PLASMA BLASTER - 100 Credits</h3>
                    <p>Larger purple projectiles, reduced fire rate, increased damage</p>
                    <button onclick="purchaseUpgrade('plasmaBlaster')" ${credits >= 100 ? 'class="affordable"' : ''}>PURCHASE</button>
                `;
                shopUpgrades.appendChild(plasmaDiv);
            }

            // Missiles - show appropriate tier
            if (upgrades.missiles < 2) {
                const missilesDiv = document.createElement('div');
                missilesDiv.className = 'upgrade';
                missilesDiv.id = 'missiles';

                if (upgrades.missiles === 0) {
                    missilesDiv.innerHTML = `
                        <h3>MISSILES TIER 1 - 100 Credits</h3>
                        <p>White rockets below blaster, slower but high damage</p>
                        <button onclick="purchaseUpgrade('missiles')" ${credits >= 100 ? 'class="affordable"' : ''}>PURCHASE</button>
                    `;
                } else if (upgrades.missiles === 1) {
                    missilesDiv.innerHTML = `
                        <h3>MISSILES TIER 2 - 200 Credits</h3>
                        <p>Second missile above blaster, same high damage</p>
                        <button onclick="purchaseUpgrade('missiles')" ${credits >= 200 ? 'class="affordable"' : ''}>UPGRADE</button>
                    `;
                }
                shopUpgrades.appendChild(missilesDiv);
            }

            // Homing Missiles - show appropriate tier
            if (upgrades.homingMissiles < 2) {
                const homingDiv = document.createElement('div');
                homingDiv.className = 'upgrade';
                homingDiv.id = 'homingMissiles';

                if (upgrades.homingMissiles === 0) {
                    homingDiv.innerHTML = `
                        <h3>HOMING MISSILES TIER 1 - 200 Credits</h3>
                        <p>Red projectiles that auto-target strongest enemy</p>
                        <button onclick="purchaseUpgrade('homingMissiles')" ${credits >= 200 ? 'class="affordable"' : ''}>PURCHASE</button>
                    `;
                } else if (upgrades.homingMissiles === 1) {
                    homingDiv.innerHTML = `
                        <h3>HOMING MISSILES TIER 2 - 400 Credits</h3>
                        <p>Second missile targets nearest healthy enemy</p>
                        <button onclick="purchaseUpgrade('homingMissiles')" ${credits >= 400 ? 'class="affordable"' : ''}>UPGRADE</button>
                    `;
                }
                shopUpgrades.appendChild(homingDiv);
            }

            // Bomb Capacity - only show if not purchased
            if (!upgrades.bombCapacity) {
                const bombDiv = document.createElement('div');
                bombDiv.className = 'upgrade';
                bombDiv.id = 'bombCapacity';
                bombDiv.innerHTML = `
                    <h3>BOMB CAPACITY UPGRADE - 350 Credits</h3>
                    <p>Increase maximum bomb capacity from 9 to 50 bombs</p>
                    <button onclick="purchaseUpgrade('bombCapacity')" ${credits >= 350 ? 'class="affordable"' : ''}>PURCHASE</button>
                `;
                shopUpgrades.appendChild(bombDiv);
            }
        }

        function closeShop() {
            const shopScreen = document.getElementById('shopScreen');
            shopScreen.classList.remove('show');
            // Wait for transition to complete before hiding
            setTimeout(() => {
                shopScreen.style.display = 'none';
                gameState = 'playing';
                // Restart the game loop
                gameLoop(performance.now());
            }, 300);
        }

        function purchaseUpgrade(upgradeType) {
            let cost = 0;
            let canPurchase = false;

            if (upgradeType === 'plasmaBlaster') {
                cost = 100;
                canPurchase = !upgrades.plasmaBlaster && credits >= cost;
            } else if (upgradeType === 'missiles') {
                cost = upgrades.missiles === 0 ? 100 : 200; // Tier 1: 100, Tier 2: 200
                canPurchase = upgrades.missiles < 2 && credits >= cost;
            } else if (upgradeType === 'homingMissiles') {
                cost = upgrades.homingMissiles === 0 ? 200 : 400; // Tier 1: 200, Tier 2: 400
                canPurchase = upgrades.homingMissiles < 2 && credits >= cost;
            } else if (upgradeType === 'bombCapacity') {
                cost = 350;
                canPurchase = !upgrades.bombCapacity && credits >= cost;
            }

            if (canPurchase) {
                credits -= cost;
                if (upgradeType === 'plasmaBlaster') {
                    upgrades.plasmaBlaster = true;
                } else if (upgradeType === 'missiles') {
                    upgrades.missiles++;
                } else if (upgradeType === 'homingMissiles') {
                    upgrades.homingMissiles++;
                } else if (upgradeType === 'bombCapacity') {
                    upgrades.bombCapacity = true;
                }

                document.getElementById('shopCredits').textContent = `Credits: ${credits}`;
                updateShopButtons();
            }
        }

        // Initialize
        loadHighScores();
        initTerrain();
        initStars();
        initAudio();
    </script>
</body>
</html>
